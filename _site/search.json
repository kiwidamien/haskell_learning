[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html",
    "href": "posts/011_applicative/011_applicatives.html",
    "title": "Applicatives",
    "section": "",
    "text": "Every Applicative is also a functor. The definition is\nclass Functor context =&gt; Applicative context where \n    pure :: a -&gt; context a\n    (&lt;*&gt;) :: context (a -&gt; b) -&gt; context a -&gt; context b\nThis extends Functor, so we already have fmap/&lt;$&gt; defined for this context as well.\nThis is something I had a lot of trouble getting used to, so let’s start with a motivating example.\n\n\n\n\nThe problem we are going to solve is building a currency converter.\nWhat we would like is to be enter a currency in one denomination, and get the value in another denomination, like so\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"NZD\"\nJust Currency \"NZD\" 109.60 \nHere we return a Maybe datatype, in case the user gives us a currency that does not exist, or that we have not tracked.\nLet’s start by assuming that all currency transactions are transitive, and then getting some currency exchange rates against the USD.\nimport qualified Data.Map as M\n\ndata Currency = Currency String Float deriving (Show, Eq)\n\noneUSDTo :: M.Map String Float\noneUSDTo = M.fromList [\n    (\"USD\", 1.00), (\"YEN\", 156.02), (\"RMB\", 7.03), \n    (\"EUR\", 0.850), (\"WON\", 1444.45), (\"NZD\", 1.71),\n    (\"AUD\", 1.49), (\"GBP\", 0.74)]\n\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nconvert rateSrc rateDest valSrc = valInUSD * rateDest\n  where valInUSD = valSrc / rateSrc\nDoing a manual lookup, 1 USD = 156.02 Yen = 1.71 NZD, so our convert function to answer the question “how many NZD is 10k YEN” would be\nghci&gt; :l converter01\nghci&gt; convert 156.02 1.71 10000\n109.60\nWe want to move from a function where you use the rates explicitly, to one where we use our lookup table.\nHere is one way to do it that works\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurrency (Currency nameSrc value) nameDest = case M.lookup nameSrc oneUSDTo of\n    Nothing -&gt; Nothing\n    Just rateSrc -&gt; case M.lookup nameDest oneUSDTo of\n        Nothing -&gt; Nothing\n        Just rateDest -&gt; Just (Currency nameDest (convert rateSrc rateDest value))\nBut this obscutes the actual logic of what we want. Let’s write something that is not valid, but gets the idea of what we want\n-- Note this doesn't work\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurreny (Currency nameSrc value) nameDest = Currency nameDest (convert' rateSrc rateDest value)\n  where rateSrc :: Maybe Float = M.lookup nameSrc oneUSDTo\n        rateDest :: Maybe Float = M.lookup nameDest oneUSDTo\n        convert' :: Maybe Float -&gt; Maybe Float -&gt; Maybe Float \n        convert' msrc mdest value = ..... -\nThere are two problems here:\n\nThe returned type is a Currency, not a Maybe Currency. We need to do the work to see if the convert' function fails.\nIf there were no Maybe functors around, we would be able to write convert' pretty simply as convert' rateSrc rateDest value = convert rateSrc rateDest value. But the rateSrc and rateDest living inside a Maybe stops us from doing this.\n\nWhen we had a function with only one argument, then fmap allowed us to push the function inside the container. An applicative will allow us to do this for functions with “multiple arguments” (technically all Haskell functions have one argument, but we often think of a function as taking multiple arguments).\n\n\n\nLet’s start with a simpler example, with the binary function addition. We know the function\n(+3) :: Num a =&gt; a -&gt; a\nis a function that takes a number to another number. If we wanted to operate on a Maybe Int, we can push the function into the Maybe as follows:\nghci&gt; fmap (+3) (Just 5)\nJust 8\nBut this doesn’t work:\nghci&gt;  fmap (+) (Just 3) (Just 5)\n-- error\nWe would need an fmap2 with an argument\nfmap2 :: (a-&gt;b-&gt;c) -&gt; context a -&gt; context b -&gt; context c\nIf we wrote fmap2, then we would need a separate fmap3 for three arguments, and so on.\nInstead, Haskell uses two operations that look weird on first glance:\nclass (Functor context) =&gt; Applicative context where\n    pure  :: a -&gt; context a\n    (&lt;*&gt;) :: context (a -&gt; b) -&gt; context a -&gt; context b\nLet’s start with why &lt;*&gt; is useful, and compare to fmap:\n  fmap :: (a -&gt; b) -&gt; context a -&gt; context b\nLet’s start by trying to apply fmap to + in the following way:\ngchi&gt; partial = fmap (+) (Just 2)\ngchi&gt; :i partial\npartial :: Num a =&gt; Maybe (a -&gt; a)\nIt might be surprising that partial was defined – doesn’t fmap only take functions of a single variable? Yes, but in Haskell all functions are a functions of a single variable! We generally think of addition as a binary operator, taking two numbers to get a number, but recall\n(+3) :: Num a =&gt; a -&gt; a\nApplying one argument (e.g. 3) to addition gives you a new function (+3), which maps a number to the number plus three. In the fmap syntax, using some extra parens:\nfmap (+) (Just 2)              =\n     (a-&gt;(a-&gt;a)) (Maybe a)     = (Maybe a-&gt;a)\nThe result of “pushing” (+) into the Maybe is that we now have a function a-&gt;a inside a Maybe. Now we can see how the\n&lt;*&gt;: Maybe (a-&gt;b) -&gt; Maybe a -&gt; Maybe b\ncan be useful. Very verbosely, we have\nghci&gt; (fmap (+) (Just 2)) &lt;*&gt; (Just 5)\nJust 7\n-- using the infix operator\nghci&gt; ( (+) &lt;$&gt; (Just 2)) &lt;*&gt; (Just 5)\nJust 7\nghci&gt; (+) &lt;$&gt; (Just 2) &lt;*&gt; (Just 5)\nJust 7\nThis gives us a general strategy:\n\nThe first fmap will place the partially applied function in the context.\nWe can then use &lt;*&gt; for all the remaining arguments, as we will get back partially applied functions in the context, or the final value in the context.\n\nWe will refine this strategy in a moment.\n\n\n\nLet’s see this at work for our conversion function:\nghci&gt; :l converter01.hs\nghci&gt; :i convert\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nghci&gt; convert &lt;$&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Let's step through it\nghci&gt; p1 = convert &lt;$&gt; (Just 1.34)\nghci&gt; :i p1\nMaybe (Float -&gt; (Float -&gt; Float))\nghci&gt; p2 = p1 &lt;*&gt; (Just 0.90)\nghci&gt; :i p2\np2 :: Maybe (Float -&gt; Float) \nghci&gt; p3 = p2 &lt;*&gt; (Just 10000)\nghci&gt; :i p3\np3 :: Maybe Float\nThere are two things that may seem unsatisfactory: 1. In our actual application, we have Maybe for the rates, as the map lookup might fail. But we have an actual value for the amount we want to convert, not a Maybe. 2. More generally, the first application is treated differently (we apply fmap/&lt;$&gt; to get our function into the context).\nThe first problem is pretty straightforward: If I have an amount::Float (not a Maybe Float) that I want to convert, I cannot use the &lt;*&gt; pattern directly. But what I can do is use Just amount, which make the amount I had and puts it into the Maybe context.\nI can actually do this with the function convert as well! This function has type Float -&gt; Float -&gt; Float -&gt; Float, but Just convert has type Just (Float -&gt; Float -&gt; Float -&gt; Float). I don’t need to apply fmap to put the function into a context, I can apply Just to it! We can see this by looking at the example above\nghci&gt; :l converter01.hs\nghci&gt; convert &lt;$&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Note that we now have a chain of &lt;*&gt;\nghci&gt; (Just convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\nThis motiviates the other function an applicative gives us: pure. It is a way of taking a “pure” value and putting it inside the applicative’s context. In the case of Maybe, this is using Just. Rewriting again:\nghci&gt; (pure convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Can also do to the 10_000 at the end\nghci&gt; (pure convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (pure 10000)\nJust 6716.4175\nUsing the “lifting” terminology, pure takes a value and “lifts” it into the context.\nLet’s give our final version of the currency calculator\nimport qualified Data.Map as M\n\ndata Currency = Currency String Float deriving (Show, Eq)\n\noneUSDTo :: M.Map String Float\noneUSDTo = M.fromList [\n    (\"USD\", 1.00), (\"YEN\", 156.02), (\"RMB\", 7.03), \n    (\"EUR\", 0.850), (\"WON\", 1444.45), (\"NZD\", 1.71),\n    (\"AUD\", 1.49), (\"GBP\", 0.74)]\n\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nconvert rateSrc rateDest valSrc = valInUSD * rateDest\n  where valInUSD = valSrc / rateSrc\n\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurrency (Currency nameSrc value) nameDest = Currency nameDest &lt;$&gt; newValue\n  where rateSrc = M.lookup nameSrc oneUSDTo\n        rateDest = M.lookup nameDest oneUSDTo\n        newValue = (pure convert) &lt;*&gt; rateSrc &lt;*&gt; rateDest &lt;*&gt; (pure value)\nRunning a couple of examples:\nghci&gt; :l converter03\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"RMB\"\nJust (Currency \"RMB\" 450.58325)\n-- Giving an example of a currency we don't have the exchange rate of, Bitcoin\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"BTC\"\nNothing\n\n\n\n\nThe main motivation for appliciatives are to use what we did with fmap (pushing functions of a single argument into a context) to other functions that take more arguments. The examples used the Maybe context extensively, but let’s generalize this to other contexts.\nFor a formal defintion, an Applicative context is also a functor (i.e. already has fmap) with two additional functions: * &lt;*&gt; :: context (a-&gt;b) -&gt; context a -&gt; context b * pure :: a -&gt; context a\nIn code, the definition is\nclass Functor context =&gt; Applicative context where \n    pure :: a -&gt; context a\n    (&lt;*&gt;) :: context (a -&gt; b) -&gt; context a -&gt; context b\nThere are also five applicative laws (not enforced by the compiler, but enforced by convention). From wikipedia:\n1. pure id &lt;*&gt; v = v                            -- Identity\n2. pure f &lt;*&gt; pure x = pure (f x)               -- Homomorphism\n3. u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u              -- Interchange\n4. pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w) -- Composition\n5. fmap f x = (pure f) &lt;*&gt; x\nLet’s start with the last one: the idea of the &lt;*&gt; operator is that it allows us to generalize fmap. We saw two different ways of doing this:\n\nUse fmap once, to get the function into the context, and then use &lt;*&gt; on the remaining partial applications\nUse (pure f) to put the function into the context, and then use &lt;*&gt; for all the partial applications.\n\nRule 5 guarantees that these two approaches do the same thing.\nThe other 4 rules capture the idea that pure puts a value in a context, while making as few other changes as possible. In words\n\nMake sure that lifting the identity function to a context gives you the identity function between contexts.\n(Applying a function and then lifting) is the same as (lifting the function, lifting the value, and then using the lifted function to transform the lifted value)\nComposition is associative.\n\nTo implement the Applicative for Maybe the code is\ninstance Applicative Maybe where\n    -- pure :: a -&gt; Maybe a\n    pure x                = Just x\n    -- &lt;*&gt; :: Maybe (a-&gt;b) -&gt; Maybe a -&gt; Maybe b\n    (Just f) &lt;*&gt; (Just x) = Just (f x)\n    _        &lt;*&gt; _        = Nothing\n\n\n\nWe have already talked about how, given a binary function binFunc we can lift the function into an applicative context Context in two ways\n-- binFunc :: a -&gt; b -&gt; c\n-- argInContext1 :: Context a\n-- argInContext2 :: Context b\nbinFunc &lt;$&gt; argInContext1 &lt;*&gt; argInContext2\n--example\n(+) &lt;$&gt; (Just 5) &lt;*&gt; (Just 10)\n-- Just 15\n\n-- OR\n(pure binFunc) &lt;*&gt; argInContext1 &lt;*&gt; argInContext2\n-- example\n(pure (+)) &lt;*&gt; (Just 5) &lt;*&gt; (Just 10)\n-- Just 15\nThere is an alternative, which is to use\nimport Control.Applicative (liftA2)\n\nliftA2 :: (a-&gt;b-&gt;c) -&gt; (Context a) -&gt; (Context b) -&gt; (Context c)\nliftA2 binFunc x y = (pure binFunc) &lt;*&gt; x &lt;*&gt; y\nThat is, liftA2 is exactly the function we wanted in the motivation section, except there we called it fmap2.\nSimilarly, there is a liftA3 that does exactly what you would expect:\nliftA3: (a-&gt;b-&gt;c-&gt;d) -&gt; Context a -&gt; Context b -&gt; Context c -&gt; Context d\nliftA3 triFunc x y z = (pure triFunc) &lt;*&gt; x &lt;*&gt; y &lt;*&gt; z\nStylewise, it is preferred to use liftA2 and liftA3 over (pure ...) &lt;*&gt; .. &lt;*&gt; .. or (..) &lt;$&gt; .. &lt;*&gt; .. &lt;*&gt; .. because the liftAN functions more clearly signals intent, and that the operators &lt;$&gt; and &lt;*&gt; can be difficult to parse. It starts to look like a regular expression.\n\n\n\n\nMaybe\nEither\nIO\n\n\n\n\n\nAll applicatives are already functors.\nThe functor fmap allows us to push a function of a single value into a context. The appliciative operator &lt;*&gt; allows us to push a function of multiple arguments into a context.\nFor example, using Maybe, and the function factorial :: n -&gt; n\n\nfactorial :: Int -&gt; Int\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\n\nfmap factorial (Just 3)       --  Just 6\nfmap factorial (Nothing)      --   Nothing\n\n-- allow (+):: Int-&gt; Int-&gt; Int to be pure (+) :: Maybe Int -&gt; Maybe Int -&gt; Maybe Int\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Just 6)   -- Just 9\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Nothing)  -- Nothing\n(+) &lt;$&gt; (Just 3) &lt;*&gt; (Nothing)  -- equivlent to above\n\n-- Let's define a ternary function\nf :: Int -&gt; Int -&gt; Int -&gt; Int\nf a b c = (a+b)*c\n\n(pure f) &lt;*&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\nf &lt;$&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\n\nFor functions with 2 or 3 arguments, often liftA2 and liftA3 from Control.Applicative are used instead, to reduce the line noise from &lt;$&gt; and &lt;*&gt;\n\n-- these are all equivalent\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Nothing)  -- Nothing\n(+) &lt;$&gt; (Just 3) &lt;*&gt; (Nothing)         -- Nothing\nliftA2 (+) (Just 3) (Nothing)          -- Nothing\n-- liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b \n\n-- these are all equivalent\n(pure f) &lt;*&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\nf &lt;$&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2)        -- Just (6+7)*2 = Just 26\nliftA3 f (Just 6) (Just 7) (Just 2)             -- Just (6+7)*2\n-- liftA2 f a b c = f &lt;$&gt; a &lt;*&gt; b  &lt;*&gt; c\n\nReally useful when chaining lookups from Maps, where the results return Maybe!\nTo use applicatives, you need to have all the values in the same context. If you have raw values, you can use pure to lift them into the context. We did this in the currency conversion example at the beginning of the chapter.\n\nIn this chapter we didn’t look at the List type as an applicative, and instead devote the next chapter to that.\nTo extend a context X to an applicative, use\ninstance Applicative X where\n    -- pure :: a -&gt; X a\n    pure x                = ....\n    -- &lt;*&gt; :: X (a-&gt;b) -&gt; X a -&gt; X b\n    &lt;*&gt;                   = ...."
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html#motivational-examples",
    "href": "posts/011_applicative/011_applicatives.html#motivational-examples",
    "title": "Applicatives",
    "section": "",
    "text": "The problem we are going to solve is building a currency converter.\nWhat we would like is to be enter a currency in one denomination, and get the value in another denomination, like so\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"NZD\"\nJust Currency \"NZD\" 109.60 \nHere we return a Maybe datatype, in case the user gives us a currency that does not exist, or that we have not tracked.\nLet’s start by assuming that all currency transactions are transitive, and then getting some currency exchange rates against the USD.\nimport qualified Data.Map as M\n\ndata Currency = Currency String Float deriving (Show, Eq)\n\noneUSDTo :: M.Map String Float\noneUSDTo = M.fromList [\n    (\"USD\", 1.00), (\"YEN\", 156.02), (\"RMB\", 7.03), \n    (\"EUR\", 0.850), (\"WON\", 1444.45), (\"NZD\", 1.71),\n    (\"AUD\", 1.49), (\"GBP\", 0.74)]\n\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nconvert rateSrc rateDest valSrc = valInUSD * rateDest\n  where valInUSD = valSrc / rateSrc\nDoing a manual lookup, 1 USD = 156.02 Yen = 1.71 NZD, so our convert function to answer the question “how many NZD is 10k YEN” would be\nghci&gt; :l converter01\nghci&gt; convert 156.02 1.71 10000\n109.60\nWe want to move from a function where you use the rates explicitly, to one where we use our lookup table.\nHere is one way to do it that works\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurrency (Currency nameSrc value) nameDest = case M.lookup nameSrc oneUSDTo of\n    Nothing -&gt; Nothing\n    Just rateSrc -&gt; case M.lookup nameDest oneUSDTo of\n        Nothing -&gt; Nothing\n        Just rateDest -&gt; Just (Currency nameDest (convert rateSrc rateDest value))\nBut this obscutes the actual logic of what we want. Let’s write something that is not valid, but gets the idea of what we want\n-- Note this doesn't work\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurreny (Currency nameSrc value) nameDest = Currency nameDest (convert' rateSrc rateDest value)\n  where rateSrc :: Maybe Float = M.lookup nameSrc oneUSDTo\n        rateDest :: Maybe Float = M.lookup nameDest oneUSDTo\n        convert' :: Maybe Float -&gt; Maybe Float -&gt; Maybe Float \n        convert' msrc mdest value = ..... -\nThere are two problems here:\n\nThe returned type is a Currency, not a Maybe Currency. We need to do the work to see if the convert' function fails.\nIf there were no Maybe functors around, we would be able to write convert' pretty simply as convert' rateSrc rateDest value = convert rateSrc rateDest value. But the rateSrc and rateDest living inside a Maybe stops us from doing this.\n\nWhen we had a function with only one argument, then fmap allowed us to push the function inside the container. An applicative will allow us to do this for functions with “multiple arguments” (technically all Haskell functions have one argument, but we often think of a function as taking multiple arguments).\n\n\n\nLet’s start with a simpler example, with the binary function addition. We know the function\n(+3) :: Num a =&gt; a -&gt; a\nis a function that takes a number to another number. If we wanted to operate on a Maybe Int, we can push the function into the Maybe as follows:\nghci&gt; fmap (+3) (Just 5)\nJust 8\nBut this doesn’t work:\nghci&gt;  fmap (+) (Just 3) (Just 5)\n-- error\nWe would need an fmap2 with an argument\nfmap2 :: (a-&gt;b-&gt;c) -&gt; context a -&gt; context b -&gt; context c\nIf we wrote fmap2, then we would need a separate fmap3 for three arguments, and so on.\nInstead, Haskell uses two operations that look weird on first glance:\nclass (Functor context) =&gt; Applicative context where\n    pure  :: a -&gt; context a\n    (&lt;*&gt;) :: context (a -&gt; b) -&gt; context a -&gt; context b\nLet’s start with why &lt;*&gt; is useful, and compare to fmap:\n  fmap :: (a -&gt; b) -&gt; context a -&gt; context b\nLet’s start by trying to apply fmap to + in the following way:\ngchi&gt; partial = fmap (+) (Just 2)\ngchi&gt; :i partial\npartial :: Num a =&gt; Maybe (a -&gt; a)\nIt might be surprising that partial was defined – doesn’t fmap only take functions of a single variable? Yes, but in Haskell all functions are a functions of a single variable! We generally think of addition as a binary operator, taking two numbers to get a number, but recall\n(+3) :: Num a =&gt; a -&gt; a\nApplying one argument (e.g. 3) to addition gives you a new function (+3), which maps a number to the number plus three. In the fmap syntax, using some extra parens:\nfmap (+) (Just 2)              =\n     (a-&gt;(a-&gt;a)) (Maybe a)     = (Maybe a-&gt;a)\nThe result of “pushing” (+) into the Maybe is that we now have a function a-&gt;a inside a Maybe. Now we can see how the\n&lt;*&gt;: Maybe (a-&gt;b) -&gt; Maybe a -&gt; Maybe b\ncan be useful. Very verbosely, we have\nghci&gt; (fmap (+) (Just 2)) &lt;*&gt; (Just 5)\nJust 7\n-- using the infix operator\nghci&gt; ( (+) &lt;$&gt; (Just 2)) &lt;*&gt; (Just 5)\nJust 7\nghci&gt; (+) &lt;$&gt; (Just 2) &lt;*&gt; (Just 5)\nJust 7\nThis gives us a general strategy:\n\nThe first fmap will place the partially applied function in the context.\nWe can then use &lt;*&gt; for all the remaining arguments, as we will get back partially applied functions in the context, or the final value in the context.\n\nWe will refine this strategy in a moment.\n\n\n\nLet’s see this at work for our conversion function:\nghci&gt; :l converter01.hs\nghci&gt; :i convert\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nghci&gt; convert &lt;$&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Let's step through it\nghci&gt; p1 = convert &lt;$&gt; (Just 1.34)\nghci&gt; :i p1\nMaybe (Float -&gt; (Float -&gt; Float))\nghci&gt; p2 = p1 &lt;*&gt; (Just 0.90)\nghci&gt; :i p2\np2 :: Maybe (Float -&gt; Float) \nghci&gt; p3 = p2 &lt;*&gt; (Just 10000)\nghci&gt; :i p3\np3 :: Maybe Float\nThere are two things that may seem unsatisfactory: 1. In our actual application, we have Maybe for the rates, as the map lookup might fail. But we have an actual value for the amount we want to convert, not a Maybe. 2. More generally, the first application is treated differently (we apply fmap/&lt;$&gt; to get our function into the context).\nThe first problem is pretty straightforward: If I have an amount::Float (not a Maybe Float) that I want to convert, I cannot use the &lt;*&gt; pattern directly. But what I can do is use Just amount, which make the amount I had and puts it into the Maybe context.\nI can actually do this with the function convert as well! This function has type Float -&gt; Float -&gt; Float -&gt; Float, but Just convert has type Just (Float -&gt; Float -&gt; Float -&gt; Float). I don’t need to apply fmap to put the function into a context, I can apply Just to it! We can see this by looking at the example above\nghci&gt; :l converter01.hs\nghci&gt; convert &lt;$&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Note that we now have a chain of &lt;*&gt;\nghci&gt; (Just convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\nThis motiviates the other function an applicative gives us: pure. It is a way of taking a “pure” value and putting it inside the applicative’s context. In the case of Maybe, this is using Just. Rewriting again:\nghci&gt; (pure convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (Just 10000)\nJust 6716.4175\n-- Can also do to the 10_000 at the end\nghci&gt; (pure convert) &lt;*&gt; (Just 1.34) &lt;*&gt; (Just 0.90) &lt;*&gt; (pure 10000)\nJust 6716.4175\nUsing the “lifting” terminology, pure takes a value and “lifts” it into the context.\nLet’s give our final version of the currency calculator\nimport qualified Data.Map as M\n\ndata Currency = Currency String Float deriving (Show, Eq)\n\noneUSDTo :: M.Map String Float\noneUSDTo = M.fromList [\n    (\"USD\", 1.00), (\"YEN\", 156.02), (\"RMB\", 7.03), \n    (\"EUR\", 0.850), (\"WON\", 1444.45), (\"NZD\", 1.71),\n    (\"AUD\", 1.49), (\"GBP\", 0.74)]\n\nconvert :: Float -&gt; Float -&gt; Float -&gt; Float\nconvert rateSrc rateDest valSrc = valInUSD * rateDest\n  where valInUSD = valSrc / rateSrc\n\nconvertCurrency :: Currency -&gt; String -&gt; Maybe Currency\nconvertCurrency (Currency nameSrc value) nameDest = Currency nameDest &lt;$&gt; newValue\n  where rateSrc = M.lookup nameSrc oneUSDTo\n        rateDest = M.lookup nameDest oneUSDTo\n        newValue = (pure convert) &lt;*&gt; rateSrc &lt;*&gt; rateDest &lt;*&gt; (pure value)\nRunning a couple of examples:\nghci&gt; :l converter03\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"RMB\"\nJust (Currency \"RMB\" 450.58325)\n-- Giving an example of a currency we don't have the exchange rate of, Bitcoin\nghci&gt; convertCurrency (Currency \"YEN\" 10000) \"BTC\"\nNothing"
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html#applicatives-and-laws",
    "href": "posts/011_applicative/011_applicatives.html#applicatives-and-laws",
    "title": "Applicatives",
    "section": "",
    "text": "The main motivation for appliciatives are to use what we did with fmap (pushing functions of a single argument into a context) to other functions that take more arguments. The examples used the Maybe context extensively, but let’s generalize this to other contexts.\nFor a formal defintion, an Applicative context is also a functor (i.e. already has fmap) with two additional functions: * &lt;*&gt; :: context (a-&gt;b) -&gt; context a -&gt; context b * pure :: a -&gt; context a\nIn code, the definition is\nclass Functor context =&gt; Applicative context where \n    pure :: a -&gt; context a\n    (&lt;*&gt;) :: context (a -&gt; b) -&gt; context a -&gt; context b\nThere are also five applicative laws (not enforced by the compiler, but enforced by convention). From wikipedia:\n1. pure id &lt;*&gt; v = v                            -- Identity\n2. pure f &lt;*&gt; pure x = pure (f x)               -- Homomorphism\n3. u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u              -- Interchange\n4. pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w) -- Composition\n5. fmap f x = (pure f) &lt;*&gt; x\nLet’s start with the last one: the idea of the &lt;*&gt; operator is that it allows us to generalize fmap. We saw two different ways of doing this:\n\nUse fmap once, to get the function into the context, and then use &lt;*&gt; on the remaining partial applications\nUse (pure f) to put the function into the context, and then use &lt;*&gt; for all the partial applications.\n\nRule 5 guarantees that these two approaches do the same thing.\nThe other 4 rules capture the idea that pure puts a value in a context, while making as few other changes as possible. In words\n\nMake sure that lifting the identity function to a context gives you the identity function between contexts.\n(Applying a function and then lifting) is the same as (lifting the function, lifting the value, and then using the lifted function to transform the lifted value)\nComposition is associative.\n\nTo implement the Applicative for Maybe the code is\ninstance Applicative Maybe where\n    -- pure :: a -&gt; Maybe a\n    pure x                = Just x\n    -- &lt;*&gt; :: Maybe (a-&gt;b) -&gt; Maybe a -&gt; Maybe b\n    (Just f) &lt;*&gt; (Just x) = Just (f x)\n    _        &lt;*&gt; _        = Nothing"
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html#style-guide-for-applicatives-lifta2-lifta3-..-liftan",
    "href": "posts/011_applicative/011_applicatives.html#style-guide-for-applicatives-lifta2-lifta3-..-liftan",
    "title": "Applicatives",
    "section": "",
    "text": "We have already talked about how, given a binary function binFunc we can lift the function into an applicative context Context in two ways\n-- binFunc :: a -&gt; b -&gt; c\n-- argInContext1 :: Context a\n-- argInContext2 :: Context b\nbinFunc &lt;$&gt; argInContext1 &lt;*&gt; argInContext2\n--example\n(+) &lt;$&gt; (Just 5) &lt;*&gt; (Just 10)\n-- Just 15\n\n-- OR\n(pure binFunc) &lt;*&gt; argInContext1 &lt;*&gt; argInContext2\n-- example\n(pure (+)) &lt;*&gt; (Just 5) &lt;*&gt; (Just 10)\n-- Just 15\nThere is an alternative, which is to use\nimport Control.Applicative (liftA2)\n\nliftA2 :: (a-&gt;b-&gt;c) -&gt; (Context a) -&gt; (Context b) -&gt; (Context c)\nliftA2 binFunc x y = (pure binFunc) &lt;*&gt; x &lt;*&gt; y\nThat is, liftA2 is exactly the function we wanted in the motivation section, except there we called it fmap2.\nSimilarly, there is a liftA3 that does exactly what you would expect:\nliftA3: (a-&gt;b-&gt;c-&gt;d) -&gt; Context a -&gt; Context b -&gt; Context c -&gt; Context d\nliftA3 triFunc x y z = (pure triFunc) &lt;*&gt; x &lt;*&gt; y &lt;*&gt; z\nStylewise, it is preferred to use liftA2 and liftA3 over (pure ...) &lt;*&gt; .. &lt;*&gt; .. or (..) &lt;$&gt; .. &lt;*&gt; .. &lt;*&gt; .. because the liftAN functions more clearly signals intent, and that the operators &lt;$&gt; and &lt;*&gt; can be difficult to parse. It starts to look like a regular expression."
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html#example-built-in-applicatives",
    "href": "posts/011_applicative/011_applicatives.html#example-built-in-applicatives",
    "title": "Applicatives",
    "section": "",
    "text": "Maybe\nEither\nIO"
  },
  {
    "objectID": "posts/011_applicative/011_applicatives.html#summary",
    "href": "posts/011_applicative/011_applicatives.html#summary",
    "title": "Applicatives",
    "section": "",
    "text": "All applicatives are already functors.\nThe functor fmap allows us to push a function of a single value into a context. The appliciative operator &lt;*&gt; allows us to push a function of multiple arguments into a context.\nFor example, using Maybe, and the function factorial :: n -&gt; n\n\nfactorial :: Int -&gt; Int\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\n\nfmap factorial (Just 3)       --  Just 6\nfmap factorial (Nothing)      --   Nothing\n\n-- allow (+):: Int-&gt; Int-&gt; Int to be pure (+) :: Maybe Int -&gt; Maybe Int -&gt; Maybe Int\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Just 6)   -- Just 9\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Nothing)  -- Nothing\n(+) &lt;$&gt; (Just 3) &lt;*&gt; (Nothing)  -- equivlent to above\n\n-- Let's define a ternary function\nf :: Int -&gt; Int -&gt; Int -&gt; Int\nf a b c = (a+b)*c\n\n(pure f) &lt;*&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\nf &lt;$&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\n\nFor functions with 2 or 3 arguments, often liftA2 and liftA3 from Control.Applicative are used instead, to reduce the line noise from &lt;$&gt; and &lt;*&gt;\n\n-- these are all equivalent\n(pure (+)) &lt;*&gt; (Just 3) &lt;*&gt; (Nothing)  -- Nothing\n(+) &lt;$&gt; (Just 3) &lt;*&gt; (Nothing)         -- Nothing\nliftA2 (+) (Just 3) (Nothing)          -- Nothing\n-- liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b \n\n-- these are all equivalent\n(pure f) &lt;*&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2) -- Just (6+7)*2 = Just 26\nf &lt;$&gt; (Just 6) &lt;*&gt; (Just 7) &lt;*&gt; (Just 2)        -- Just (6+7)*2 = Just 26\nliftA3 f (Just 6) (Just 7) (Just 2)             -- Just (6+7)*2\n-- liftA2 f a b c = f &lt;$&gt; a &lt;*&gt; b  &lt;*&gt; c\n\nReally useful when chaining lookups from Maps, where the results return Maybe!\nTo use applicatives, you need to have all the values in the same context. If you have raw values, you can use pure to lift them into the context. We did this in the currency conversion example at the beginning of the chapter.\n\nIn this chapter we didn’t look at the List type as an applicative, and instead devote the next chapter to that.\nTo extend a context X to an applicative, use\ninstance Applicative X where\n    -- pure :: a -&gt; X a\n    pure x                = ....\n    -- &lt;*&gt; :: X (a-&gt;b) -&gt; X a -&gt; X b\n    &lt;*&gt;                   = ...."
  },
  {
    "objectID": "posts/002_functions_and_types.html",
    "href": "posts/002_functions_and_types.html",
    "title": "Functions and Types",
    "section": "",
    "text": "Functions and Types\nIn Haskell, every value has a type. For example\n\n1.0 is a Fractional\n1 can be either an Integer or an Int (annoyingly, these are different)\n[1,2,3] is either a list of Integer or a list of Int (annoyingly, these are different)\n('a', 'c') is a tuple of Charaters\n'a' is a Char\n\"a\"’ is a String, with only one character in it\n\"hello\" is a String\n\nA difference between Python and Haskell is that in Python, a list can contain many different types. In Haskell, a list can only contain one type:\n\n[1,2,3]: Okay in both\n['a', 'b', 'c']: Okay in both\n[1, 2, 'a']: Okay in Python, not allowed in Haskell\n\nA function takes exactly one argument, and returns a single value"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/001_getting_started.html",
    "href": "posts/001_getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "Getting started"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "The next two chapters – Monads and Map Lookups, and Monads as IO – are going to serve as motivating examples for what additional tools we need. This chapter looks at Maybe as a Monad, with containers (Maps) in the background. Then we look at IO as a Monad that explicitly encodes effects. After giving these examples as motivations, the next chapter will define a Monad in terms of the operations it supports, and without having to mention effects or Maybe, as these are not essential elements of a Monad.\nThe nice thing about starting with Maybe as a Monad is that we can still deal with pure code, and not tie the idea that Monads are necessarily tied to effects. The downside is that it is possible, using pattern matching or case statements, to get around the need for Monads in this case: while the code is uglier, you can always “extract” the a out of Just a, and then deal with Nothing separately.\nThe IO Monad forces us to have to operate within the IO context, as we don’t have a way of extracting the String out of an IO String. I put this as a separate motivating example, because IO requires introducing a new set of functions that we haven’t used yet, and I wanted to reduce confusion by first giving an example of a Monad using only familiar functions.\n\n\nSuppose we had two maps:\n\nzipToCity :: M.Map Int String. Given a zip code Int, return the city name String.\ncityToState :: M.Map String String. Given a city name, return the state.\n\nThis is not a great representation for this problem (in particular, the same city name can appear in many states, such as Springfield which exists in 34 states). We are going to assume that all our city names are unique, so this problem does not occur, so that we can make an example with minimal explaination.\nHow would we write a function that, given a zip code, would tell you the State?\nHere is one work working example of the code:\nimport qualified Data.Map as M\n\nzipToCity :: M.Map Int String\nzipToCity = M.fromList [(95616, \"Davis\"), \n                        (94102, \"San Francisco\"), (94103, \"San Francisco\"), (94014, \"San Francisco\"),\n                        (30033, \"Atlanta\"), (30301, \"Atlanta\"), (30307, \"Atlanta\")]\n                        \ncityToState :: M.Map String String\ncityToState = M.fromList [(\"Davis\", \"CA\"), (\"San Francisco\", \"CA\"), (\"Atlanta\", \"GA\")]\n\n\nuseZipCodeFindState :: Int -&gt; Maybe String\nuseZipCodeFindState zipCode = case M.lookup zipCode zipToCity of\n    Nothing -&gt; Nothing\n    Just cityName -&gt; M.lookup cityName cityToState\nThis works, but we can generalize this a little bit: * A Map lookup is lookup :: a -&gt; M.Map a b -&gt; Maybe b, that is we are taking ordinary values outside of a Maybe context, and getting a result in a Maybe context. * When chaining lookups, it is difficult because we need the original value (not in a Maybe). We can do the deconstruction above, but it is a lot of noise * When we get a Nothing, we usually want to pass that through to the end. It doesn’t add a lot of value for us to pass the Nothing explicitly at each chained lookup.\nAnother way of phrasing this problem is\nlookupCityFromZip :: Int -&gt; Maybe String\nlookupCityFromZip zipCode = M.lookup zipCode zipToCity\n\nlookupStateFromCity :: String -&gt; Maybe String\nlookupStateFromCity cityName = M.lookup cityName cityToState\n\n-- What we want\n-- useZipCodeFindState :: Int -&gt; Maybe String\n\n\n\nWe have\n-- From applicative:\npure ::        a       -&gt; Maybe a\n&lt;$&gt;  ::       (a -&gt; b) -&gt; Maybe a -&gt; Maybe b\n&lt;*&gt;  :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b\n\n-- Functions that exist\nlookupCityFromZip :: Int -&gt; Maybe String\nlookupStateFromCity :: String -&gt; Maybe String\n\n-- Want\nuseZipCodeFindState :: Int -&gt; Maybe String\nWhat we need is something that can take the result of the first lookup (Maybe String), and the lookup function (String -&gt; Maybe String), and give us back the result Maybe String.\nWe can try &lt;$&gt; with a = String and b = Maybe String. Then we have lookupStateFromCity as a function from a -&gt; b. We feed it a type Maybe a. Unfortunately, we get back a type Maybe b = Maybe(Maybe String)\nghci&gt; test zipCode = lookupStateFromCity &lt;$&gt; (lookupCityFromZip zipCode)\nghci&gt; test 95616\nJust (Just \"CA\")\nghci&gt; :t test\ntest :: Int -&gt; Maybe (Maybe String)\nNo combination will actually do it. We need to either\n\nbe able to collapse sequential Maybe contexts (i.e. make a Maybe(Maybe String) into a Maybe String)\nor have a fucntion with the signature (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b\n\nIt turns out that these will be two equivalent ways of solving the problem! The first one is called join, and the second is called (reverse) bind. You can express join in terms of bind, or bind in terms of join, so we will pick one and move forward with it.\nWe pick reverse bind:\n=&lt;&lt;   :: (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b\nNow we can contruct our chain of lookups:\nghci&gt; lookupCityFromZip           --  Int -&gt; Maybe String \nghci&gt; lookupCityFromZip 95616     -- Maybe String\n-- Lets take a = String, b = String. Then =&lt;&lt; \n--     a (String -&gt; Maybe String) function, lookupStateFromCity\n--     a Maybe String value, lookupCityFromZip 95616\n--     returns a Maybe String value\nghci&gt; (=&lt;&lt;) (lookupStateFromCity) (lookupCityFromZip 95616) -- Maybe String\n-- equivalent as an infix operator\nghci&gt; (lookupStateFromCity) =&lt;&lt; (lookupCityFromZip 95616) \n-- i.e. useZipCodeFindState zipCode = lookupStateFromCity =&lt;&lt; (lookupCityFromZip zipCode)\n\n\n\nExtending beyond Maybe, we have a pair of very similar functions:\n=&lt;&lt; :: (a -&gt; Context b) -&gt; Context a -&gt; Context b  -- reverse bind\n&gt;&gt;= :: Context a -&gt; (a -&gt; Context b) -&gt; Context b  -- bind\nThese functions are not meaningfully different, we have f =&lt;&lt; x and x &gt;&gt;= f as functionally the same thing.\nReverse bind makes more sense when comparing to &lt;*&gt; and &lt;$&gt;, and looks more similar to function application (first give the function, then the value in the context being acted on). Haskell programmers tend to use bind or &gt;&gt;=, which takes the value in context and then pushes it through the function.\nWhen I was looking at bind, it seemed somewhat unnatural to do &gt;&gt;=, as you start with the value in the context, and then try to push it through a function. This is the complete opposite of what we do with functors and applicatives! However, often when starting to learn Haskell, we often have a value like an IO String, or a Maybe Bool, and the temptation is to ask “how do I get the value out of the context?”. Instead, we should operate on the context. Because this is such a frequent sticking point, most Haskell teaching resources prefer bind &gt;&gt;= as you start with the troublesome object and then apply a function to it.\nYou could write our function useZipCodeFindState in either of the following ways:\n-- Using reverse bind =&lt;&lt;.\n-- Looks like regular function application:\n--      start with (lookupCityFromZip zipCode) and get an output\n--      take what is \"inside the context\" as the argument to lookupStateFromCity\n--      just like g $ f x is g( f(x) )\nuseZipCodeFindState zipCode = lookupStateFromCity =&lt;&lt; (lookupCityFromZip zipCode)\n\n-- Using bind &gt;&gt;= \n-- thought of as a function is weird, but it works well thinking about Unix pipes\n-- 1. Calculate (lookupCityFromZip zipCode)\n-- 2. Take the result from \"inside the context\" as the argument to lookupStateFromCity\n-- 3. Calculate\n-- The arrows are a visual reminder of which way we are pushing the data.\nuseZipCodeFindState zipCode = (lookupCityFromZip zipCode) &gt;&gt;= lookupStateFromCity\n\n\n\nIn our motivating example, we saw that we could almost get away with fmap, except that we accumulated contexts. Specifically, we had\nghci&gt; test zipCode = lookupStateFromCity &lt;$&gt; (lookupCityFromZip zipCode)\ngchi&gt; :t test\ntest :: Int -&gt; Maybe (Maybe String)\nwhere what we really wanted was a function from Int -&gt; Maybe String.\nLet’s generalize this. We have two functions, and they each take values (not in a Context), but outputs that are in a Context, and we want to chain them together:\nf1 :: a -&gt; Context b  -- e.g. lookupCityFromZip :: Int -&gt; Maybe String\nf2 :: b -&gt; Context c  -- e.g. lookupStateFromCity :: String -&gt; Maybe String\n\n-- want\nchained :: a -&gt; Context c\n\n-- can make\ndoubleContext :: a -&gt; Context(Context c)\ndoubleContext aType = f2 &lt;$&gt; f1 aType\nLet’s walk through the types:\n\nf1 aType: is of type Context b\nfmap f2 (f1 aType) has to take inputs (X-&gt;Y) and Context X, and has an output Context Y.\n\nLooking at f2 :: b -&gt; Context c this means X = b and Y = Context c.\nSo this has an output Context Y = Context (Context c).\n\n\nIf it were possible to flatten the Context, we would have what we want! There is a function that does exactly this, called join:\njoin :: Context (Context a) -&gt; Context a\nLet’s assume that we can write join as a function. Then we have two ways of combining f1 and f2 to make chained:\n-- use fmap and then collapse double context to a single context\nchained1 :: a -&gt; Context c\nchained1 aType = join $ doubleContext aType = join $ (f2 &lt;$&gt; f1 aType)\n\n-- use &gt;&gt;=\nchained2 :: a -&gt; Context c\nchained2 aType = f2 &lt;&lt;= (f1 aType)\nThese two approaches give the same result!\n\n\nNiether join nor bind are more fundamental. Given one, you can define the other, to guarantee that the chained1 and chained2 approaches do the same thing.\nRecall that &gt;&gt;= :: Context a -&gt; (a -&gt; Context b) -&gt; Context b. We want a function join :: Context (Context c) -&gt; Context c. This suggests:\n\na = Context c and b=c in &gt;&gt;=, so we start with Context (Context c) and end with Context c\nWe need a function (a -&gt; Context b) = (Context c -&gt; Context c). The simplest such function is the identity.\n\nAnd this turns out to be the definition of join:\njoin :: Context (Context C) -&gt; Context C\njoin cca = cca &gt;&gt;= id\nLet’s say that we had a join function. Can we make bind? Yes we can! From our example above\nchained1 :: a -&gt; Context c\nchained1 aType = join $ (f2 &lt;$&gt; f1 aType)\n\nchained2 :: a -&gt; Context c\nchained2 aType = (&gt;&gt;=) (f1 aType) f2\nBecause these are the same, we have\n(&gt;&gt;=) (f1 aType) f2 = join $ (f2 &lt;$&gt; f1 aType)\n\n-- as a definition\n(&gt;&gt;=) :: Context a -&gt; (a -&gt; Context b) -&gt; Context b\n(&gt;&gt;=) ca fa_to_cb = join $ (fa_to_cb &lt;$&gt; ca)\n\n\n\n\nMonad implementation needs us to implement (&gt;&gt;=). The compiler could have made join more fundamental, but didn’t.\ninstance Monad MyMonad where\n  (&gt;&gt;=) = ...\nLet’s do this for Maybe\n-- Note this won't run, as it conflicts with the existing declaration in the compiler\ninstance Monad Maybe where\n    -- (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b\n    (&gt;&gt;=) Nothing _ = Nothing\n    (&gt;&gt;=) (Just a) f = f a\nWhat would join be? Let’s write it manually, and then also in terms of bind\n-- these will run!\njoin :: Monad m =&gt; m (m a) -&gt; m a\njoin mma = mma &gt;&gt;= id\n\njoin' :: Maybe (Maybe a) -&gt; Maybe a\njoin' mma = case mma of \n    Nothing -&gt; Nothing\n    Just ma -&gt; ma\n\n\n\nThe approach of introducing Monads via sequential map lookups was inspired by Get Programming With Haskell by William Kurt.\nThe safediv was inspired by Graham Hutton’s introduction to Monads."
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#example-chaining-two-maps",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#example-chaining-two-maps",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "Suppose we had two maps:\n\nzipToCity :: M.Map Int String. Given a zip code Int, return the city name String.\ncityToState :: M.Map String String. Given a city name, return the state.\n\nThis is not a great representation for this problem (in particular, the same city name can appear in many states, such as Springfield which exists in 34 states). We are going to assume that all our city names are unique, so this problem does not occur, so that we can make an example with minimal explaination.\nHow would we write a function that, given a zip code, would tell you the State?\nHere is one work working example of the code:\nimport qualified Data.Map as M\n\nzipToCity :: M.Map Int String\nzipToCity = M.fromList [(95616, \"Davis\"), \n                        (94102, \"San Francisco\"), (94103, \"San Francisco\"), (94014, \"San Francisco\"),\n                        (30033, \"Atlanta\"), (30301, \"Atlanta\"), (30307, \"Atlanta\")]\n                        \ncityToState :: M.Map String String\ncityToState = M.fromList [(\"Davis\", \"CA\"), (\"San Francisco\", \"CA\"), (\"Atlanta\", \"GA\")]\n\n\nuseZipCodeFindState :: Int -&gt; Maybe String\nuseZipCodeFindState zipCode = case M.lookup zipCode zipToCity of\n    Nothing -&gt; Nothing\n    Just cityName -&gt; M.lookup cityName cityToState\nThis works, but we can generalize this a little bit: * A Map lookup is lookup :: a -&gt; M.Map a b -&gt; Maybe b, that is we are taking ordinary values outside of a Maybe context, and getting a result in a Maybe context. * When chaining lookups, it is difficult because we need the original value (not in a Maybe). We can do the deconstruction above, but it is a lot of noise * When we get a Nothing, we usually want to pass that through to the end. It doesn’t add a lot of value for us to pass the Nothing explicitly at each chained lookup.\nAnother way of phrasing this problem is\nlookupCityFromZip :: Int -&gt; Maybe String\nlookupCityFromZip zipCode = M.lookup zipCode zipToCity\n\nlookupStateFromCity :: String -&gt; Maybe String\nlookupStateFromCity cityName = M.lookup cityName cityToState\n\n-- What we want\n-- useZipCodeFindState :: Int -&gt; Maybe String"
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#attempts-to-build-from-fmap-or",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#attempts-to-build-from-fmap-or",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "We have\n-- From applicative:\npure ::        a       -&gt; Maybe a\n&lt;$&gt;  ::       (a -&gt; b) -&gt; Maybe a -&gt; Maybe b\n&lt;*&gt;  :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b\n\n-- Functions that exist\nlookupCityFromZip :: Int -&gt; Maybe String\nlookupStateFromCity :: String -&gt; Maybe String\n\n-- Want\nuseZipCodeFindState :: Int -&gt; Maybe String\nWhat we need is something that can take the result of the first lookup (Maybe String), and the lookup function (String -&gt; Maybe String), and give us back the result Maybe String.\nWe can try &lt;$&gt; with a = String and b = Maybe String. Then we have lookupStateFromCity as a function from a -&gt; b. We feed it a type Maybe a. Unfortunately, we get back a type Maybe b = Maybe(Maybe String)\nghci&gt; test zipCode = lookupStateFromCity &lt;$&gt; (lookupCityFromZip zipCode)\nghci&gt; test 95616\nJust (Just \"CA\")\nghci&gt; :t test\ntest :: Int -&gt; Maybe (Maybe String)\nNo combination will actually do it. We need to either\n\nbe able to collapse sequential Maybe contexts (i.e. make a Maybe(Maybe String) into a Maybe String)\nor have a fucntion with the signature (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b\n\nIt turns out that these will be two equivalent ways of solving the problem! The first one is called join, and the second is called (reverse) bind. You can express join in terms of bind, or bind in terms of join, so we will pick one and move forward with it.\nWe pick reverse bind:\n=&lt;&lt;   :: (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b\nNow we can contruct our chain of lookups:\nghci&gt; lookupCityFromZip           --  Int -&gt; Maybe String \nghci&gt; lookupCityFromZip 95616     -- Maybe String\n-- Lets take a = String, b = String. Then =&lt;&lt; \n--     a (String -&gt; Maybe String) function, lookupStateFromCity\n--     a Maybe String value, lookupCityFromZip 95616\n--     returns a Maybe String value\nghci&gt; (=&lt;&lt;) (lookupStateFromCity) (lookupCityFromZip 95616) -- Maybe String\n-- equivalent as an infix operator\nghci&gt; (lookupStateFromCity) =&lt;&lt; (lookupCityFromZip 95616) \n-- i.e. useZipCodeFindState zipCode = lookupStateFromCity =&lt;&lt; (lookupCityFromZip zipCode)"
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#reverse-bind-and-bind",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#reverse-bind-and-bind",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "Extending beyond Maybe, we have a pair of very similar functions:\n=&lt;&lt; :: (a -&gt; Context b) -&gt; Context a -&gt; Context b  -- reverse bind\n&gt;&gt;= :: Context a -&gt; (a -&gt; Context b) -&gt; Context b  -- bind\nThese functions are not meaningfully different, we have f =&lt;&lt; x and x &gt;&gt;= f as functionally the same thing.\nReverse bind makes more sense when comparing to &lt;*&gt; and &lt;$&gt;, and looks more similar to function application (first give the function, then the value in the context being acted on). Haskell programmers tend to use bind or &gt;&gt;=, which takes the value in context and then pushes it through the function.\nWhen I was looking at bind, it seemed somewhat unnatural to do &gt;&gt;=, as you start with the value in the context, and then try to push it through a function. This is the complete opposite of what we do with functors and applicatives! However, often when starting to learn Haskell, we often have a value like an IO String, or a Maybe Bool, and the temptation is to ask “how do I get the value out of the context?”. Instead, we should operate on the context. Because this is such a frequent sticking point, most Haskell teaching resources prefer bind &gt;&gt;= as you start with the troublesome object and then apply a function to it.\nYou could write our function useZipCodeFindState in either of the following ways:\n-- Using reverse bind =&lt;&lt;.\n-- Looks like regular function application:\n--      start with (lookupCityFromZip zipCode) and get an output\n--      take what is \"inside the context\" as the argument to lookupStateFromCity\n--      just like g $ f x is g( f(x) )\nuseZipCodeFindState zipCode = lookupStateFromCity =&lt;&lt; (lookupCityFromZip zipCode)\n\n-- Using bind &gt;&gt;= \n-- thought of as a function is weird, but it works well thinking about Unix pipes\n-- 1. Calculate (lookupCityFromZip zipCode)\n-- 2. Take the result from \"inside the context\" as the argument to lookupStateFromCity\n-- 3. Calculate\n-- The arrows are a visual reminder of which way we are pushing the data.\nuseZipCodeFindState zipCode = (lookupCityFromZip zipCode) &gt;&gt;= lookupStateFromCity"
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#join-and-bind",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#join-and-bind",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "In our motivating example, we saw that we could almost get away with fmap, except that we accumulated contexts. Specifically, we had\nghci&gt; test zipCode = lookupStateFromCity &lt;$&gt; (lookupCityFromZip zipCode)\ngchi&gt; :t test\ntest :: Int -&gt; Maybe (Maybe String)\nwhere what we really wanted was a function from Int -&gt; Maybe String.\nLet’s generalize this. We have two functions, and they each take values (not in a Context), but outputs that are in a Context, and we want to chain them together:\nf1 :: a -&gt; Context b  -- e.g. lookupCityFromZip :: Int -&gt; Maybe String\nf2 :: b -&gt; Context c  -- e.g. lookupStateFromCity :: String -&gt; Maybe String\n\n-- want\nchained :: a -&gt; Context c\n\n-- can make\ndoubleContext :: a -&gt; Context(Context c)\ndoubleContext aType = f2 &lt;$&gt; f1 aType\nLet’s walk through the types:\n\nf1 aType: is of type Context b\nfmap f2 (f1 aType) has to take inputs (X-&gt;Y) and Context X, and has an output Context Y.\n\nLooking at f2 :: b -&gt; Context c this means X = b and Y = Context c.\nSo this has an output Context Y = Context (Context c).\n\n\nIf it were possible to flatten the Context, we would have what we want! There is a function that does exactly this, called join:\njoin :: Context (Context a) -&gt; Context a\nLet’s assume that we can write join as a function. Then we have two ways of combining f1 and f2 to make chained:\n-- use fmap and then collapse double context to a single context\nchained1 :: a -&gt; Context c\nchained1 aType = join $ doubleContext aType = join $ (f2 &lt;$&gt; f1 aType)\n\n-- use &gt;&gt;=\nchained2 :: a -&gt; Context c\nchained2 aType = f2 &lt;&lt;= (f1 aType)\nThese two approaches give the same result!\n\n\nNiether join nor bind are more fundamental. Given one, you can define the other, to guarantee that the chained1 and chained2 approaches do the same thing.\nRecall that &gt;&gt;= :: Context a -&gt; (a -&gt; Context b) -&gt; Context b. We want a function join :: Context (Context c) -&gt; Context c. This suggests:\n\na = Context c and b=c in &gt;&gt;=, so we start with Context (Context c) and end with Context c\nWe need a function (a -&gt; Context b) = (Context c -&gt; Context c). The simplest such function is the identity.\n\nAnd this turns out to be the definition of join:\njoin :: Context (Context C) -&gt; Context C\njoin cca = cca &gt;&gt;= id\nLet’s say that we had a join function. Can we make bind? Yes we can! From our example above\nchained1 :: a -&gt; Context c\nchained1 aType = join $ (f2 &lt;$&gt; f1 aType)\n\nchained2 :: a -&gt; Context c\nchained2 aType = (&gt;&gt;=) (f1 aType) f2\nBecause these are the same, we have\n(&gt;&gt;=) (f1 aType) f2 = join $ (f2 &lt;$&gt; f1 aType)\n\n-- as a definition\n(&gt;&gt;=) :: Context a -&gt; (a -&gt; Context b) -&gt; Context b\n(&gt;&gt;=) ca fa_to_cb = join $ (fa_to_cb &lt;$&gt; ca)"
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#maybe-implementation-of-join-and-bind",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#maybe-implementation-of-join-and-bind",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "Monad implementation needs us to implement (&gt;&gt;=). The compiler could have made join more fundamental, but didn’t.\ninstance Monad MyMonad where\n  (&gt;&gt;=) = ...\nLet’s do this for Maybe\n-- Note this won't run, as it conflicts with the existing declaration in the compiler\ninstance Monad Maybe where\n    -- (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b\n    (&gt;&gt;=) Nothing _ = Nothing\n    (&gt;&gt;=) (Just a) f = f a\nWhat would join be? Let’s write it manually, and then also in terms of bind\n-- these will run!\njoin :: Monad m =&gt; m (m a) -&gt; m a\njoin mma = mma &gt;&gt;= id\n\njoin' :: Maybe (Maybe a) -&gt; Maybe a\njoin' mma = case mma of \n    Nothing -&gt; Nothing\n    Just ma -&gt; ma"
  },
  {
    "objectID": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#references",
    "href": "posts/013_monads_as_map_lookup/013_monad_as_map_lookup.html#references",
    "title": "Monads as Map Lookups",
    "section": "",
    "text": "The approach of introducing Monads via sequential map lookups was inspired by Get Programming With Haskell by William Kurt.\nThe safediv was inspired by Graham Hutton’s introduction to Monads."
  },
  {
    "objectID": "posts/014_monads_with_basic_io/014_monad_with_io_basic.html",
    "href": "posts/014_monads_with_basic_io/014_monad_with_io_basic.html",
    "title": "Monad with IO",
    "section": "",
    "text": "The previous chapter showed how bind or &gt;&gt;= / =&lt;&lt; allowed us do more with pushing functions into the Maybe context. It may have felt like overkill, because for a Maybe we always have the ability to operate within the Maybe context by using\ng :: a -&gt; b\ng anA = ......\n\nf :: Maybe a -&gt; Maybe b\nf maybeA = case maybeA of\n    Just anA -&gt; Just (g anA)\n    Nothing -&gt; Nothing\nSo while we don’t “take the a out of Maybe a”, we can use case to make a branch and operate on the a as above. It doesn’t feel that much wierder than the bind solution f maybeA = anA &gt;&gt;= g.\nWhen using the IO\n\n\n\n\nLet’s write a function that takes a string, breaks it into words, and then constructs a new string “Last word. Repeat sentence”. If written as a name, it will take “Last Name. Full Name” as the output (here we literally mean last name, as in the last name written, which may or may not be the family name).\nbondLikeIntro :: String -&gt; String\nbondLikeIntro \"\" = \"\"\nbondLikeIntro name = (last $ words name) ++ \". \" ++ name\n\nbondLikeIntro \"James Bond\"    -- \"Bond. James Bond\"\nbondLikeIntro \"Homer Simpson\" -- \"Simpson. Homer Simpson\"\nWe can simulate getting IO from the user like this\nghci&gt; :l bond_name.hs\nghci&gt; name_from_user = pure \"Marge Simpson\"::IO String\nghci&gt; :i name_from_user \nname_from_user :: IO String \ni.e. the pure has “lifted” the string into the IO context.\nHow would we apply our function on an IO String? This is just fmap!\n-- Using IO as the context\n-- &lt;$&gt; :: (a -&gt; b) -&gt; IO a -&gt; IO b\n-- We have a function String -&gt; String, we want to apply, so\n-- (&lt;$&gt;) bondLikeIntro :: IO String -&gt; IO String\nghci&gt; (&lt;$&gt;) bondLikeIntro name_from_user -- returns \"Simpson. Marge Simpson\"::IO String\nghci&gt; bondLikeIntro &lt;$&gt; name_from_user   -- same return, but uses infix operator\nNow let’s say we wanted to print this out. The REPL will do this for us automatically, but this wouldn’t work if we put it in a script. We want to use the function putStrLn :: String -&gt; IO ().\n\nWe have the IO String, bondLikeIntro &lt;$&gt; name_from_user that we want to print\nWe have a function putStrLn :: String -&gt; IO ()\nSo we have a monad like thing: &gt;&gt;= :: (IO String) -&gt; (String -&gt; IO ()) -&gt; (IO ())\n\nWe can’t “get” the string \"Simpson. Marge Simpson\" out of the IO String, but we can use the Monad to push putStrLn into the IO context the IO String already has:\nghci&gt; (&gt;&gt;=) (bondLikeIntro &lt;$&gt; name_from_user) putStrLn  -- returns IO ()\nSimpson. Marge Simpson                                   -- This is a printed side effect\n-- equivalent infix:\nghci&gt; (bondLikeIntro &lt;$&gt; name_from_user) &gt;&gt;= putStrLn    -- returns IO ()\nSimpson. Marge Simpson                                   -- This is a printed side effect\nFinally, we can wrap this up into a total script as follows\nbondLikeIntro :: String -&gt; String\nbondLikeIntro \"\" = \"\"\nbondLikeIntro name = (last $ words name) ++ \". \" ++ name\n-- Examples:\n-- bondLikeIntro \"James Bond\"    -- \"Bond. James Bond\"\n-- bondLikeIntro \"Homer Simpson\" -- \"Simpson. Homer Simpson\"\n\ncoolUserIntro :: IO ()\ncoolUserIntro = putStrLn \"Name?\" &gt;&gt;= (\\_ -&gt; bondLikeIntro &lt;$&gt; getLine ) &gt;&gt;= putStrLn\nWe can run this in the interpreter as follows\nghci&gt; :l bond_name01\nghci&gt; coolUserIntro \nName?\nDamien Martin\nMartin. Damien Martin\nThrough the rest of this chapter, we are going to tidy up our coolUserIntro function in different ways:\n\nIntroducing the &gt;&gt; operator\nSequencing more idiomatically\nIntroducing the do notation"
  },
  {
    "objectID": "posts/014_monads_with_basic_io/014_monad_with_io_basic.html#example",
    "href": "posts/014_monads_with_basic_io/014_monad_with_io_basic.html#example",
    "title": "Monad with IO",
    "section": "",
    "text": "Let’s write a function that takes a string, breaks it into words, and then constructs a new string “Last word. Repeat sentence”. If written as a name, it will take “Last Name. Full Name” as the output (here we literally mean last name, as in the last name written, which may or may not be the family name).\nbondLikeIntro :: String -&gt; String\nbondLikeIntro \"\" = \"\"\nbondLikeIntro name = (last $ words name) ++ \". \" ++ name\n\nbondLikeIntro \"James Bond\"    -- \"Bond. James Bond\"\nbondLikeIntro \"Homer Simpson\" -- \"Simpson. Homer Simpson\"\nWe can simulate getting IO from the user like this\nghci&gt; :l bond_name.hs\nghci&gt; name_from_user = pure \"Marge Simpson\"::IO String\nghci&gt; :i name_from_user \nname_from_user :: IO String \ni.e. the pure has “lifted” the string into the IO context.\nHow would we apply our function on an IO String? This is just fmap!\n-- Using IO as the context\n-- &lt;$&gt; :: (a -&gt; b) -&gt; IO a -&gt; IO b\n-- We have a function String -&gt; String, we want to apply, so\n-- (&lt;$&gt;) bondLikeIntro :: IO String -&gt; IO String\nghci&gt; (&lt;$&gt;) bondLikeIntro name_from_user -- returns \"Simpson. Marge Simpson\"::IO String\nghci&gt; bondLikeIntro &lt;$&gt; name_from_user   -- same return, but uses infix operator\nNow let’s say we wanted to print this out. The REPL will do this for us automatically, but this wouldn’t work if we put it in a script. We want to use the function putStrLn :: String -&gt; IO ().\n\nWe have the IO String, bondLikeIntro &lt;$&gt; name_from_user that we want to print\nWe have a function putStrLn :: String -&gt; IO ()\nSo we have a monad like thing: &gt;&gt;= :: (IO String) -&gt; (String -&gt; IO ()) -&gt; (IO ())\n\nWe can’t “get” the string \"Simpson. Marge Simpson\" out of the IO String, but we can use the Monad to push putStrLn into the IO context the IO String already has:\nghci&gt; (&gt;&gt;=) (bondLikeIntro &lt;$&gt; name_from_user) putStrLn  -- returns IO ()\nSimpson. Marge Simpson                                   -- This is a printed side effect\n-- equivalent infix:\nghci&gt; (bondLikeIntro &lt;$&gt; name_from_user) &gt;&gt;= putStrLn    -- returns IO ()\nSimpson. Marge Simpson                                   -- This is a printed side effect\nFinally, we can wrap this up into a total script as follows\nbondLikeIntro :: String -&gt; String\nbondLikeIntro \"\" = \"\"\nbondLikeIntro name = (last $ words name) ++ \". \" ++ name\n-- Examples:\n-- bondLikeIntro \"James Bond\"    -- \"Bond. James Bond\"\n-- bondLikeIntro \"Homer Simpson\" -- \"Simpson. Homer Simpson\"\n\ncoolUserIntro :: IO ()\ncoolUserIntro = putStrLn \"Name?\" &gt;&gt;= (\\_ -&gt; bondLikeIntro &lt;$&gt; getLine ) &gt;&gt;= putStrLn\nWe can run this in the interpreter as follows\nghci&gt; :l bond_name01\nghci&gt; coolUserIntro \nName?\nDamien Martin\nMartin. Damien Martin\nThrough the rest of this chapter, we are going to tidy up our coolUserIntro function in different ways:\n\nIntroducing the &gt;&gt; operator\nSequencing more idiomatically\nIntroducing the do notation"
  },
  {
    "objectID": "posts/010_functors/010_functors.html",
    "href": "posts/010_functors/010_functors.html",
    "title": "Functors",
    "section": "",
    "text": "A functor is a way of mapping values that are in a context, while preserving the context. While this can be used for any context, we will start by looking at some container types to gain intuition.\nclass Functor context  where \n    fmap :: (a -&gt; b) -&gt; context a -&gt; context b\n    (&lt;$) :: a -&gt; context b -&gt; context a\nThat is, if we have a way of transforming a to b, and a context that is also a functor, then we can take an a or as living into a context and transform them into b or bs living in the same context.\nBefore giving the laws of Functors, let’s give two examples of common Functors: Lists and Maybe. The functors (i.e. fmap) is already predefined for these structures, so we can use it and think about what fmap is trying to do before seeing how we would implement it.\nThe canonical example is a list. Let’s say we have a list of strings, and a function length :: String -&gt; Int that takes a single string, and gives the length of that string. In this case, fmap is just map:\nghci&gt; map length [\"cat\", \"dog\", \"rabbit\"]\n[3,3,6]\nghci&gt; fmap length [\"cat\", \"dog\", \"rabbit\"]\n[3,3,6]\nThe list in this example is a context for storing multiple strings. Let’s refer to this context as a structure. We went through the “structure” [\"cat\", \"dog\", \"rabbit\"] one element at a time, and applied our function length to each element, and then gave the output back in the same “structure”. For a list, the fmap implementation literally is map!\nThe second example is for the structure Maybe. Let’s say we have a Maybe Int, and we want to add five to it. We can do this with a function\naddFive maybeNum = case maybeNum of\n    Just x -&gt; x + 5\n    Nothing -&gt; Nothing\nbut having to make a different function if we wanted to add 6 is a pain and verbose. Instead we can use fmap for the Maybe structure:\nghci&gt; fmap (+5) (Just 6)\nJust 11\nghci&gt; fmap (+5) (Nothing)\nNothing\n\n\nGiven a Abstract Data Type structure a (that is, a structure like a List, Maybe, Tree, Either, IO, etc) that wraps elements of type a, a functor maps over the values contained insiide the structure and applies a function to them, returning the wrapped values.\nLet’s make an artificial Maybe, and then make it a functor\ndata MyMaybe a = MyJust a | MyNothing deriving (Eq, Show)\n\ninstance Functor MyMaybe where\n    fmap :: (a -&gt; b) -&gt; MyMaybe a -&gt; MyMaybe b\n    fmap f (MyJust a) = MyJust (f a)\n    fmap f (MyNothing) = MyNothing\nThat is, we can extend any of our custom built types to get functor behavior. We now get the same behavior as we did with Maybe:\nghci&gt; :l mymaybe_functor\nghci&gt; fmap (+5) (MyJust 6)\nMyJust 11\nghci&gt; fmap (+5) (MyNothing)\nMyNothing\nThere are also two functor laws that we have to abide by. These are not enforced by the language, but by convention. Code written using fmap assumes that these two conditions hold:\n\nThe law of identity: fmap id == id\nThe law of composition: fmap (f.g) = (fmap f) . (fmap g)\n\n\n\n\nLet’s suppose we made a Tree class:\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\nWe can build an explicit binary tree\nexampleBinaryTree = Node 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) (Empty)) (Node 60 Empty Empty))\nHow would we produce a new tree, with the same skeleton, but each value doubled? We could write a function to do that, but let’s implement fmap for the tree.\ninstance Functor Node where\n    fmap :: (a -&gt; b) -&gt; Node a -&gt; Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)\nNow you can write\nghci&gt; :l mytree_functor\nghci&gt; exampleBinaryTree\nNode 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) Empty) (Node 60 Empty Empty))\nghci&gt; fmap (*2) exampleBinaryTree\nNode 60 (Node 40 (Leaf 32) (Leaf 50)) (Node 100 (Node 80 (Leaf 70) Empty) (Node 120 Empty Empty))\n\n\n\nFor a container type (e.g. List, Map, our implemented Tree), fmap is a generalized version of map for lists. We go through the container, one element at a time, and have the same shape and type of container at the end.\nOur functions that map the elements don’t need to know what type of data structure we are going to apply them over; instead by defining the data structure as a functor the data structure knows how to map over all the values.\nfmap is used more generally than just containers. For example, Maybe, Either, IO are all contexts that hold one or zero values. We know that we cannot think about extracting the value from the context; if we make something a functor it allows us to “push” functions into the context and apply them.\nThe IO context is one that causes trouble, as at the beginning we see IO String and want to know how to get the String out of IO String. You can’t (or at least, you shouldn’t). But we can use fmap to perform operations on IO String if we have functions that work on String types:\nghci&gt; x = readFile \"mytree_functor.hs\"\n-- x is type IO String\ngchi&gt; length x\n-- error: no function length::IO String -&gt; ......\nghci&gt; fmap length x\n385   \n-- length :: String -&gt; Int, or more generally any foldable to Int,\n-- so (fmap length x) has type IO Int\n-- we didn't extract the string from the IO Context, we \"pushed\" length\n-- into the context to operate on the value inside. \nghci&gt; length &lt;$&gt; x  -- &lt;$&gt; is the infix version of fmap\n385\nghci&gt; y = fmap length x\nghci&gt; :i y\ny :: IO Int\nWe also gain the ability to write a function once that doesn’t care what type of “functor” context it will later get mapped on to, including ones that have not been written yet!\n\n\n\nAs shown in the example above, we can write fmap as an infix operator:\n-- option 1\nfmap f x\n-- option 2\nf &lt;$&gt; x\nThese both mean the same thing.\n\n\n\nSo far we have talked about fmap f (X a) as “pushing” the function f into the context described by X, and operating on the a elements in the context.\nAn alterative way of thinking about fmap is, given a function f:: a -&gt; b, then the partial application g = fmap f is a function g:: X a -&gt; X b. That is, fmap transforms a function between the values and transforms it into a function that maps values in a context to values in another context.\nThis is referred to “lifting” in the Haskell community. The function f operated between values, but the function g = fmap f has been “lifted” into the context X. It now maps between values in a context.\n\n\n\n\nfmap is a generalization of what map was to list types.\n\nmap f (x:xs): take a list as input, apply f to each element, and get a list as output.\nfmap f (x:xs): the same, on lists fmap = map\nFor a container context, you generally get the same idea: you get a new container with the same “shape”, but each element transformed by f.\n\nfmap is not only for containers! It works for contexts that cannot be thought of as containers. Intuitively, it “pushes” the value f into the context, but you get a result with the same context.\nExamples for built-in contexts. Let’s use even :: Int -&gt; Bool in each example\n\nfmap even [1,2,3] = [False, True, False]: start with a list, end with a list\nfmap even (Just 3) = Just False: Start with a Maybe, end with a Maybe\nfmap even (Nothing) = Nothing: Start with a Maybe, end with a Maybe\nfmap even (Left 2) = Left 2: Start with an Either, end with an Either\nfmap even (Right 2) = Right True: Start with an Either, end with an Either\nfmap even (return 2::IO Int) = True: The right side is True::IO Bool\n\nWhen writing a functor class, you should make sure that the identity function id does nothing when fmapped: fmap id = id.\nYou should also make sure that your fmap implementation respects function composition:\n\nfmap (f.g) x = (fmap f) (fmap g x)\nIn infix notation: (f.g) &lt;$&gt; x = f &lt;$&gt; g &lt;$&gt; x\n\n\nTo implement a functor on your own data type X, use\ninstance Functor X where\n    fmap :: (a -&gt; b) -&gt; X a -&gt; X b\n    ....\nAs a concrete example, here is the functor implementation on a Node datatype for a binary tree\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\n\ninstance Functor Node where\n    fmap :: (a -&gt; b) -&gt; Node a -&gt; Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)"
  },
  {
    "objectID": "posts/010_functors/010_functors.html#implementing-a-functor-and-functor-laws",
    "href": "posts/010_functors/010_functors.html#implementing-a-functor-and-functor-laws",
    "title": "Functors",
    "section": "",
    "text": "Given a Abstract Data Type structure a (that is, a structure like a List, Maybe, Tree, Either, IO, etc) that wraps elements of type a, a functor maps over the values contained insiide the structure and applies a function to them, returning the wrapped values.\nLet’s make an artificial Maybe, and then make it a functor\ndata MyMaybe a = MyJust a | MyNothing deriving (Eq, Show)\n\ninstance Functor MyMaybe where\n    fmap :: (a -&gt; b) -&gt; MyMaybe a -&gt; MyMaybe b\n    fmap f (MyJust a) = MyJust (f a)\n    fmap f (MyNothing) = MyNothing\nThat is, we can extend any of our custom built types to get functor behavior. We now get the same behavior as we did with Maybe:\nghci&gt; :l mymaybe_functor\nghci&gt; fmap (+5) (MyJust 6)\nMyJust 11\nghci&gt; fmap (+5) (MyNothing)\nMyNothing\nThere are also two functor laws that we have to abide by. These are not enforced by the language, but by convention. Code written using fmap assumes that these two conditions hold:\n\nThe law of identity: fmap id == id\nThe law of composition: fmap (f.g) = (fmap f) . (fmap g)"
  },
  {
    "objectID": "posts/010_functors/010_functors.html#implementation-for-a-tree",
    "href": "posts/010_functors/010_functors.html#implementation-for-a-tree",
    "title": "Functors",
    "section": "",
    "text": "Let’s suppose we made a Tree class:\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\nWe can build an explicit binary tree\nexampleBinaryTree = Node 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) (Empty)) (Node 60 Empty Empty))\nHow would we produce a new tree, with the same skeleton, but each value doubled? We could write a function to do that, but let’s implement fmap for the tree.\ninstance Functor Node where\n    fmap :: (a -&gt; b) -&gt; Node a -&gt; Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)\nNow you can write\nghci&gt; :l mytree_functor\nghci&gt; exampleBinaryTree\nNode 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) Empty) (Node 60 Empty Empty))\nghci&gt; fmap (*2) exampleBinaryTree\nNode 60 (Node 40 (Leaf 32) (Leaf 50)) (Node 100 (Node 80 (Leaf 70) Empty) (Node 120 Empty Empty))"
  },
  {
    "objectID": "posts/010_functors/010_functors.html#what-did-this-get-us",
    "href": "posts/010_functors/010_functors.html#what-did-this-get-us",
    "title": "Functors",
    "section": "",
    "text": "For a container type (e.g. List, Map, our implemented Tree), fmap is a generalized version of map for lists. We go through the container, one element at a time, and have the same shape and type of container at the end.\nOur functions that map the elements don’t need to know what type of data structure we are going to apply them over; instead by defining the data structure as a functor the data structure knows how to map over all the values.\nfmap is used more generally than just containers. For example, Maybe, Either, IO are all contexts that hold one or zero values. We know that we cannot think about extracting the value from the context; if we make something a functor it allows us to “push” functions into the context and apply them.\nThe IO context is one that causes trouble, as at the beginning we see IO String and want to know how to get the String out of IO String. You can’t (or at least, you shouldn’t). But we can use fmap to perform operations on IO String if we have functions that work on String types:\nghci&gt; x = readFile \"mytree_functor.hs\"\n-- x is type IO String\ngchi&gt; length x\n-- error: no function length::IO String -&gt; ......\nghci&gt; fmap length x\n385   \n-- length :: String -&gt; Int, or more generally any foldable to Int,\n-- so (fmap length x) has type IO Int\n-- we didn't extract the string from the IO Context, we \"pushed\" length\n-- into the context to operate on the value inside. \nghci&gt; length &lt;$&gt; x  -- &lt;$&gt; is the infix version of fmap\n385\nghci&gt; y = fmap length x\nghci&gt; :i y\ny :: IO Int\nWe also gain the ability to write a function once that doesn’t care what type of “functor” context it will later get mapped on to, including ones that have not been written yet!"
  },
  {
    "objectID": "posts/010_functors/010_functors.html#syntatic-sugar-as-fmap-infix",
    "href": "posts/010_functors/010_functors.html#syntatic-sugar-as-fmap-infix",
    "title": "Functors",
    "section": "",
    "text": "As shown in the example above, we can write fmap as an infix operator:\n-- option 1\nfmap f x\n-- option 2\nf &lt;$&gt; x\nThese both mean the same thing."
  },
  {
    "objectID": "posts/010_functors/010_functors.html#the-lifting-metaphor",
    "href": "posts/010_functors/010_functors.html#the-lifting-metaphor",
    "title": "Functors",
    "section": "",
    "text": "So far we have talked about fmap f (X a) as “pushing” the function f into the context described by X, and operating on the a elements in the context.\nAn alterative way of thinking about fmap is, given a function f:: a -&gt; b, then the partial application g = fmap f is a function g:: X a -&gt; X b. That is, fmap transforms a function between the values and transforms it into a function that maps values in a context to values in another context.\nThis is referred to “lifting” in the Haskell community. The function f operated between values, but the function g = fmap f has been “lifted” into the context X. It now maps between values in a context."
  },
  {
    "objectID": "posts/010_functors/010_functors.html#summary",
    "href": "posts/010_functors/010_functors.html#summary",
    "title": "Functors",
    "section": "",
    "text": "fmap is a generalization of what map was to list types.\n\nmap f (x:xs): take a list as input, apply f to each element, and get a list as output.\nfmap f (x:xs): the same, on lists fmap = map\nFor a container context, you generally get the same idea: you get a new container with the same “shape”, but each element transformed by f.\n\nfmap is not only for containers! It works for contexts that cannot be thought of as containers. Intuitively, it “pushes” the value f into the context, but you get a result with the same context.\nExamples for built-in contexts. Let’s use even :: Int -&gt; Bool in each example\n\nfmap even [1,2,3] = [False, True, False]: start with a list, end with a list\nfmap even (Just 3) = Just False: Start with a Maybe, end with a Maybe\nfmap even (Nothing) = Nothing: Start with a Maybe, end with a Maybe\nfmap even (Left 2) = Left 2: Start with an Either, end with an Either\nfmap even (Right 2) = Right True: Start with an Either, end with an Either\nfmap even (return 2::IO Int) = True: The right side is True::IO Bool\n\nWhen writing a functor class, you should make sure that the identity function id does nothing when fmapped: fmap id = id.\nYou should also make sure that your fmap implementation respects function composition:\n\nfmap (f.g) x = (fmap f) (fmap g x)\nIn infix notation: (f.g) &lt;$&gt; x = f &lt;$&gt; g &lt;$&gt; x\n\n\nTo implement a functor on your own data type X, use\ninstance Functor X where\n    fmap :: (a -&gt; b) -&gt; X a -&gt; X b\n    ....\nAs a concrete example, here is the functor implementation on a Node datatype for a binary tree\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\n\ninstance Functor Node where\n    fmap :: (a -&gt; b) -&gt; Node a -&gt; Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Haskell4py",
    "section": "",
    "text": "Monads as Map Lookups\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonad with IO\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions and Types\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApplicatives\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nDec 23, 2025\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nDec 20, 2025\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]