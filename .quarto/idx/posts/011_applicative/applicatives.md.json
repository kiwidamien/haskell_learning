{"title":"Applicatives","markdown":{"headingText":"Applicatives","containsRefs":false,"markdown":"\nEvery Applicative is also a functor. The definition is \n```haskell\nclass Functor context => Applicative context where \n    pure :: a -> context a\n    (<*>) :: context (a -> b) -> context a -> context b\n```\nThis extends `Functor`, so we already have `fmap/<$>` defined for this context as well.\n\nThis is something I had a lot of trouble getting used to, so let's start with a motivating example.\n\n## Motivational examples\n\n### Currency converter\n\nThe problem we are going to solve is building a currency converter. \n\nWhat we would _like_ is to be enter a currency in one denomination, and get the value in another denomination, like so\n```haskell\nghci> convertCurrency (Currency \"YEN\" 10000) \"NZD\"\nJust Currency \"NZD\" 109.60 \n```\nHere we return a `Maybe` datatype, in case the user gives us a currency that does not exist, or that we have not tracked.\n\nLet's start by assuming that all currency transactions are transitive, and then getting some currency exchange rates against the USD.\n```haskell\n{{< include converter01.hs >}}\n```\nDoing a manual lookup, 1 USD = 156.02 Yen = 1.71 NZD, so our convert function to answer the question \"how many NZD is 10k YEN\" would be\n```haskell\nghci> :l converter01\nghci> convert 156.02 1.71 10000\n109.60\n```\nWe want to move from a function where you use the rates explicitly, to one where we use our lookup table.\n\nHere is one way to do it that works\n```haskell\nconvertCurrency :: Currency -> String -> Maybe Currency\nconvertCurrency (Currency nameSrc value) nameDest = case M.lookup nameSrc oneUSDTo of\n    Nothing -> Nothing\n    Just rateSrc -> case M.lookup nameDest oneUSDTo of\n        Nothing -> Nothing\n        Just rateDest -> Just (Currency nameDest (convert rateSrc rateDest value))\n```\n\nBut this obscutes the actual logic of what we want. Let's write something that is _not_ valid, but gets the idea of what we want\n```haskell\n-- Note this doesn't work\nconvertCurrency :: Currency -> String -> Maybe Currency\nconvertCurreny (Currency nameSrc value) nameDest = Currency nameDest (convert' rateSrc rateDest value)\n  where rateSrc :: Maybe Float = M.lookup nameSrc oneUSDTo\n        rateDest :: Maybe Float = M.lookup nameDest oneUSDTo\n        convert' :: Maybe Float -> Maybe Float -> Maybe Float \n        convert' msrc mdest value = ..... -\n```\nThere are two problems here:\n1. The returned type is a `Currency`, not a `Maybe Currency`. We need to do the work to see if the `convert'` function fails.\n2. If there were no `Maybe` functors around, we would be able to write `convert'` pretty simply as `convert' rateSrc rateDest value = convert rateSrc rateDest value`. But the `rateSrc` and `rateDest` living inside a `Maybe` stops us from doing this.\n\nWhen we had a function with only one argument, then `fmap` allowed us to push the function inside the container. An applicative will allow us to do this for functions with \"multiple arguments\" (technically all Haskell functions have one argument, but we often think of a function as taking multiple arguments).\n\n### Binary functions: why `fmap` isn't enough\n\nLet's start with a simpler example, with the binary function addition. We know the function \n```haskell\n(+3) :: Num a => a -> a\n```\nis a function that takes a number to another number. If we wanted to operate on a `Maybe Int`, we can push the function into the `Maybe` as follows:\n```haskell\nghci> fmap (+3) (Just 5)\nJust 8\n```\nBut this doesn't work:\n```haskell\nghci>  fmap (+) (Just 3) (Just 5)\n-- error\n```\nWe would need an `fmap2` with an argument\n```haskell\nfmap2 :: (a->b->c) -> context a -> context b -> context c\n```\nIf we wrote `fmap2`, then we would need a separate `fmap3` for three arguments, and so on.\n\nInstead, Haskell uses two operations that look weird on first glance:\n```haskell\nclass (Functor context) => Applicative context where\n    pure  :: a -> context a\n    (<*>) :: context (a -> b) -> context a -> context b\n```\n\n\nLet's start with why `<*>` is useful, and compare to `fmap`:\n```haskell\n  fmap :: (a -> b) -> context a -> context b\n```\nLet's start by trying to apply `fmap` to `+` in the following way:\n```haskell\ngchi> partial = fmap (+) (Just 2)\ngchi> :i partial\npartial :: Num a => Maybe (a -> a)\n```\nIt might be surprising that `partial` was defined -- doesn't `fmap` only take functions of a single variable? Yes, but in Haskell all functions are a functions of a single variable! We generally think of addition as a binary operator, taking two numbers to get a number, but recall\n```haskell\n(+3) :: Num a => a -> a\n```\nApplying one argument (e.g. 3) to addition gives you a new function `(+3)`, which maps a number to the number plus three. In the `fmap` syntax, using some extra parens:\n```\nfmap (+) (Just 2)              =\n     (a->(a->a)) (Maybe a)     = (Maybe a->a)\n```\nThe result of \"pushing\" `(+)` into the `Maybe` is that we now have a function `a->a` inside a `Maybe`. Now we can see how the \n```haskell\n<*>: Maybe (a->b) -> Maybe a -> Maybe b\n```\ncan be useful. Very verbosely, we have\n```haskell\nghci> (fmap (+) (Just 2)) <*> (Just 5)\nJust 7\n-- using the infix operator\nghci> ( (+) <$> (Just 2)) <*> (Just 5)\nJust 7\nghci> (+) <$> (Just 2) <*> (Just 5)\nJust 7\n```\n\nThis gives us a general strategy:\n1. The first `fmap` will place the partially applied function in the context.\n2. We can then use `<*>` for all the remaining arguments, as we will get back partially applied functions in the context, or the final value in the context.\n\nWe will refine this strategy in a moment.\n\n### Back to the currency converter \n\nLet's see this at work for our conversion function:\n```haskell\nghci> :l converter01.hs\nghci> :i convert\nconvert :: Float -> Float -> Float -> Float\nghci> convert <$> (Just 1.34) <*> (Just 0.90) <*> (Just 10000)\nJust 6716.4175\n-- Let's step through it\nghci> p1 = convert <$> (Just 1.34)\nghci> :i p1\nMaybe (Float -> (Float -> Float))\nghci> p2 = p1 <*> (Just 0.90)\nghci> :i p2\np2 :: Maybe (Float -> Float) \nghci> p3 = p2 <*> (Just 10000)\nghci> :i p3\np3 :: Maybe Float\n```\n\nThere are two things that may seem unsatisfactory:\n1. In our actual application, we have `Maybe` for the rates, as the map lookup might fail. But we have an actual value for the amount we want to convert, not a `Maybe`.\n2. More generally, the first application is treated differently (we apply `fmap/<$>` to get our function into the context). \n\nThe first problem is pretty straightforward: If I have an `amount::Float` (not a `Maybe Float`) that I want to convert, I cannot use the `<*>` pattern directly. But what I can do is use `Just amount`, which make the amount I had and puts it into the `Maybe` context.\n\nI can actually do this with the function `convert` as well! This function has type `Float -> Float -> Float -> Float`, but `Just convert` has type `Just (Float -> Float -> Float -> Float)`. I don't need to apply `fmap` to put the function into a context, I can apply `Just` to it! We can see this by looking at the example above\n```haskell\nghci> :l converter01.hs\nghci> convert <$> (Just 1.34) <*> (Just 0.90) <*> (Just 10000)\nJust 6716.4175\n-- Note that we now have a chain of <*>\nghci> (Just convert) <*> (Just 1.34) <*> (Just 0.90) <*> (Just 10000)\nJust 6716.4175\n```\nThis motiviates the other function an applicative gives us: `pure`. It is a way of taking a \"pure\" value and putting it inside the applicative's context. In the case of `Maybe`, this is using `Just`. Rewriting again:\n```haskell\nghci> (pure convert) <*> (Just 1.34) <*> (Just 0.90) <*> (Just 10000)\nJust 6716.4175\n-- Can also do to the 10_000 at the end\nghci> (pure convert) <*> (Just 1.34) <*> (Just 0.90) <*> (pure 10000)\nJust 6716.4175\n```\nUsing the \"lifting\" terminology, `pure` takes a value and \"lifts\" it into the context.\n\nLet's give our final version of the currency calculator\n```haskell\n{{< include converter03.hs >}}\n```\n\nRunning a couple of examples:\n```haskell\nghci> :l converter03\nghci> convertCurrency (Currency \"YEN\" 10000) \"RMB\"\nJust (Currency \"RMB\" 450.58325)\n-- Giving an example of a currency we don't have the exchange rate of, Bitcoin\nghci> convertCurrency (Currency \"YEN\" 10000) \"BTC\"\nNothing\n```\n\n## Applicatives and laws\n\nThe main motivation for appliciatives are to use what we did with `fmap` (pushing functions of a single argument into a context) to other functions that take more arguments. The examples used the `Maybe` context extensively, but let's generalize this to other contexts.\n\nFor a formal defintion, an Applicative `context` is also a functor (i.e. already has `fmap`) with two additional functions:\n* `<*> :: context (a->b) -> context a -> context b`\n* `pure :: a -> context a`\n\nIn code, the definition is \n```haskell\nclass Functor context => Applicative context where \n    pure :: a -> context a\n    (<*>) :: context (a -> b) -> context a -> context b\n```\n\nThere are also five applicative laws (not enforced by the compiler, but enforced by convention). From wikipedia:\n```haskell\n1. pure id <*> v = v                            -- Identity\n2. pure f <*> pure x = pure (f x)               -- Homomorphism\n3. u <*> pure y = pure ($ y) <*> u              -- Interchange\n4. pure (.) <*> u <*> v <*> w = u <*> (v <*> w) -- Composition\n5. fmap f x = (pure f) <*> x\n```\nLet's start with the last one: the idea of the `<*>` operator is that it allows us to generalize `fmap`. We saw two different ways of doing this:\n\n*  Use `fmap` once, to get the function into the context, and then use `<*>` on the remaining partial applications\n* Use `(pure f)` to put the function into the context, and then use `<*>` for all the partial applications.\n\nRule 5 guarantees that these two approaches do the same thing.\n\nThe other 4 rules capture the idea that `pure` puts a value in a context, while making as few other changes as possible. In words\n\n1. Make sure that lifting the identity function to a context gives you the identity function between contexts.\n2. (Applying a function and then lifting) is the same as (lifting the function, lifting the value, and then using the lifted function to transform the lifted value)\n4. Composition is associative.\n\nTo implement the Applicative for `Maybe` the code is\n```haskell\ninstance Applicative Maybe where\n    -- pure :: a -> Maybe a\n    pure x                = Just x\n    -- <*> :: Maybe (a->b) -> Maybe a -> Maybe b\n    (Just f) <*> (Just x) = Just (f x)\n    _        <*> _        = Nothing\n```\n\n\n## Style guide for applicatives: `liftA2`, `liftA3`, .., `liftAN`\n\nWe have already talked about how, given a binary function `binFunc` we can lift the function into an applicative context `Context` in two ways\n```haskell\n-- binFunc :: a -> b -> c\n-- argInContext1 :: Context a\n-- argInContext2 :: Context b\nbinFunc <$> argInContext1 <*> argInContext2\n--example\n(+) <$> (Just 5) <*> (Just 10)\n-- Just 15\n\n-- OR\n(pure binFunc) <*> argInContext1 <*> argInContext2\n-- example\n(pure (+)) <*> (Just 5) <*> (Just 10)\n-- Just 15\n```\n\nThere is an alternative, which is to use\n```haskell\nimport Control.Applicative (liftA2)\n\nliftA2 :: (a->b->c) -> (Context a) -> (Context b) -> (Context c)\nliftA2 binFunc x y = (pure binFunc) <*> x <*> y\n```\nThat is, `liftA2` is exactly the function we wanted in the motivation section, except there we called it `fmap2`.\n\nSimilarly, there is a `liftA3` that does exactly what you would expect:\n```haskell\nliftA3: (a->b->c->d) -> Context a -> Context b -> Context c -> Context d\nliftA3 triFunc x y z = (pure triFunc) <*> x <*> y <*> z\n```\n\nStylewise, it is preferred to use `liftA2` and `liftA3` over `(pure ...) <*> .. <*> ..` or `(..) <$> .. <*> .. <*> ..` because the `liftAN` functions more clearly signals intent, and that the operators `<$>` and `<*>` can be difficult to parse. It starts to look like a regular expression.\n\n## Example built-in applicatives\n- Maybe\n- Either\n -IO\n\n\n## Summary\n\n* All applicatives are already functors.\n* The functor `fmap` allows us to push a function of a single value into a context. The appliciative operator `<*>` allows us to push a function of multiple arguments into a context.\n* For example, using `Maybe`, and the function `factorial :: n -> n`\n```haskell\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\n\nfmap factorial (Just 3)       --  Just 6\nfmap factorial (Nothing)      --   Nothing\n\n-- allow (+):: Int-> Int-> Int to be pure (+) :: Maybe Int -> Maybe Int -> Maybe Int\n(pure (+)) <*> (Just 3) <*> (Just 6)   -- Just 9\n(pure (+)) <*> (Just 3) <*> (Nothing)  -- Nothing\n(+) <$> (Just 3) <*> (Nothing)  -- equivlent to above\n\n-- Let's define a ternary function\nf :: Int -> Int -> Int -> Int\nf a b c = (a+b)*c\n\n(pure f) <*> (Just 6) <*> (Just 7) <*> (Just 2) -- Just (6+7)*2 = Just 26\nf <$> (Just 6) <*> (Just 7) <*> (Just 2) -- Just (6+7)*2 = Just 26\n```\n* For functions with 2 or 3 arguments, often `liftA2` and `liftA3` from `Control.Applicative` are used instead, to reduce the line noise from `<$>` and `<*>`\n```haskell\n-- these are all equivalent\n(pure (+)) <*> (Just 3) <*> (Nothing)  -- Nothing\n(+) <$> (Just 3) <*> (Nothing)         -- Nothing\nliftA2 (+) (Just 3) (Nothing)          -- Nothing\n-- liftA2 f a b = f <$> a <*> b \n\n-- these are all equivalent\n(pure f) <*> (Just 6) <*> (Just 7) <*> (Just 2) -- Just (6+7)*2 = Just 26\nf <$> (Just 6) <*> (Just 7) <*> (Just 2)        -- Just (6+7)*2 = Just 26\nliftA3 f (Just 6) (Just 7) (Just 2)             -- Just (6+7)*2\n-- liftA2 f a b c = f <$> a <*> b  <*> c\n```\n* Really useful when chaining lookups from Maps, where the results return `Maybe`!\n* To use applicatives, you need to have all the values in the same context. If you have raw values, you can use `pure` to lift them into the context. We did this in the currency conversion example at the beginning of the chapter.\n\nIn this chapter we didn't look at the `List` type as an applicative, and instead devote the next chapter to that.\n\nTo extend a context `X` to an applicative, use\n```haskell\ninstance Applicative X where\n    -- pure :: a -> X a\n    pure x                = ....\n    -- <*> :: X (a->b) -> X a -> X b\n    <*>                   = ....\n```\n\n\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"applicatives.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":"cosmo","title-block-banner":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}