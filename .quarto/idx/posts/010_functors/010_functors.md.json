{"title":"Functors","markdown":{"headingText":"Functors","containsRefs":false,"markdown":"A functor is a way of mapping values that are in a context, while preserving the context. While this can be used for any context, we will start by looking at some container types to gain intuition.\n\n\n```haskell\nclass Functor context  where \n    fmap :: (a -> b) -> context a -> context b\n    (<$) :: a -> context b -> context a\n```\n\nThat is, if we have a way of transforming `a` to `b`, and a `context` that is also a functor, then we can take an `a` or `a`s living into a context and transform them into `b` or `b`s living in the same context.\n\n\nBefore giving the laws of Functors, let's give two examples of common Functors: Lists and Maybe. The functors (i.e. `fmap`) is already predefined for these structures, so we can use it and think about what `fmap` is trying to do before seeing how we would implement it.\n\nThe canonical example is a list. Let's say we have a list of strings, and a function `length :: String -> Int` that takes a single string, and gives the length of that string. In this case, `fmap` is just `map`:\n```haskell\nghci> map length [\"cat\", \"dog\", \"rabbit\"]\n[3,3,6]\nghci> fmap length [\"cat\", \"dog\", \"rabbit\"]\n[3,3,6]\n```\nThe list in this example is a context for storing multiple strings. Let's refer to this context as a structure. We went through the \"structure\" `[\"cat\", \"dog\", \"rabbit\"]` one element at a time, and applied our function `length` to each element, and then gave the output back in the same \"structure\". For a list, the `fmap` implementation literally is `map`!\n\nThe second example is for the structure `Maybe`. Let's say we have a `Maybe Int`, and we want to add five to it. We can do this with a function\n```haskell\naddFive maybeNum = case maybeNum of\n    Just x -> x + 5\n    Nothing -> Nothing\n```\nbut having to make a different function if we wanted to add 6 is a pain and verbose. Instead we can use `fmap` for the `Maybe` structure:\n```haskell\nghci> fmap (+5) (Just 6)\nJust 11\nghci> fmap (+5) (Nothing)\nNothing\n```\n\n## Implementing a Functor and Functor Laws\n\nGiven a Abstract Data Type `structure a` (that is, a structure like a List, Maybe, Tree, Either, IO, etc) that wraps elements of type `a`, a functor maps over the values contained insiide the structure and applies a function to them, returning the wrapped values.\n\nLet's make an artificial Maybe, and then make it a functor\n```haskell\ndata MyMaybe a = MyJust a | MyNothing deriving (Eq, Show)\n\ninstance Functor MyMaybe where\n    fmap :: (a -> b) -> MyMaybe a -> MyMaybe b\n    fmap f (MyJust a) = MyJust (f a)\n    fmap f (MyNothing) = MyNothing\n```\n\nThat is, we can extend any of our custom built types to get functor behavior. We now get the same behavior as we did with `Maybe`:\n```haskell\nghci> :l mymaybe_functor\nghci> fmap (+5) (MyJust 6)\nMyJust 11\nghci> fmap (+5) (MyNothing)\nMyNothing\n```\n\nThere are also two functor laws that we have to abide by. These are not enforced by the language, but by convention. Code written using `fmap` assumes that these two conditions hold:\n\n* The law of identity: `fmap id == id`\n* The law of composition: `fmap (f.g) = (fmap f) . (fmap g)`\n\n\n## Implementation for a Tree\n\nLet's suppose we made a Tree class:\n```haskell\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\n```\n\nWe can build an explicit binary tree\n```haskell\nexampleBinaryTree = Node 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) (Empty)) (Node 60 Empty Empty))\n```\n\nHow would we produce a new tree, with the same skeleton, but each value doubled? We could write a function to do that, but let's implement `fmap` for the tree.\n\n```haskell\ninstance Functor Node where\n    fmap :: (a -> b) -> Node a -> Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)\n```\n\nNow you can write \n```haskell\nghci> :l mytree_functor\nghci> exampleBinaryTree\nNode 30 (Node 20 (Leaf 16) (Leaf 25)) (Node 50 (Node 40 (Leaf 35) Empty) (Node 60 Empty Empty))\nghci> fmap (*2) exampleBinaryTree\nNode 60 (Node 40 (Leaf 32) (Leaf 50)) (Node 100 (Node 80 (Leaf 70) Empty) (Node 120 Empty Empty))\n```\n\n## What did this get us?\n\nFor a container type (e.g. List, Map, our implemented Tree), `fmap` is a generalized version of `map` for lists. We go through the container, one element at a time, and have the same shape and type of container at the end. \n\nOur functions that map the elements don't need to know what type of data structure we are going to apply them over; instead by defining the data structure as a functor the data structure knows how to map over all the values.\n\n`fmap` is used more generally than just containers. For example, `Maybe`, `Either`, `IO` are all contexts that hold one or zero values. We know that we cannot think about extracting the value from the context; if we make something a functor it allows us to \"push\" functions _into_ the context and apply them.\n\nThe `IO` context is one that causes trouble, as at the beginning we see `IO String` and want to know how to get the `String` out of `IO String`. You can't (or at least, you shouldn't). But we can use `fmap` to perform operations on `IO String` if we have functions that work on `String` types:\n\n```haskell\nghci> x = readFile \"mytree_functor.hs\"\n-- x is type IO String\ngchi> length x\n-- error: no function length::IO String -> ......\nghci> fmap length x\n385   \n-- length :: String -> Int, or more generally any foldable to Int,\n-- so (fmap length x) has type IO Int\n-- we didn't extract the string from the IO Context, we \"pushed\" length\n-- into the context to operate on the value inside. \nghci> length <$> x  -- <$> is the infix version of fmap\n385\nghci> y = fmap length x\nghci> :i y\ny :: IO Int\n```\n\nWe also gain the ability to write a function once that doesn't care what type of \"functor\" context it will later get mapped on to, including ones that have not been written yet!\n\n## Syntatic sugar: <$> as fmap infix\n\nAs shown in the example above, we can write `fmap` as an infix operator:\n```haskell\n-- option 1\nfmap f x\n-- option 2\nf <$> x\n```\nThese both mean the same thing.\n\n## The \"lifting\" metaphor\n\nSo far we have talked about `fmap f (X a)` as \"pushing\" the function `f` into the context described by `X`, and operating on the `a` elements in the context.\n\nAn alterative way of thinking about `fmap` is, given a function `f:: a -> b`, then the partial application `g = fmap f` is a function `g:: X a -> X b`. That is, `fmap` transforms a function between the values and transforms it into a function that maps values in a context to values in another context. \n\nThis is referred to \"lifting\" in the Haskell community. The function `f` operated between values, but the function `g = fmap f` has been \"lifted\" into the context `X`. It now maps between values in a context.\n\n## Summary\n\n* `fmap` is a generalization of what `map` was to `list` types.\n  * `map f (x:xs)`: take a list as input, apply `f` to each element, and get a list as output.\n  * `fmap f (x:xs)`: the same, on lists `fmap = map`\n  * For a _container_ context, you generally get the same idea: you get a new container with the same \"shape\", but each element transformed by `f`.\n* `fmap` is not only for containers! It works for contexts that cannot be thought of as containers. Intuitively, it \"pushes\" the value `f` into the context, but you get a result with the same context.\n* Examples for built-in contexts. Let's use `even :: Int -> Bool` in each example\n  * `fmap even [1,2,3] = [False, True, False]`: start with a list, end with a list\n  * `fmap even (Just 3) = Just False`: Start with a Maybe, end with a Maybe\n  * `fmap even (Nothing) = Nothing`: Start with a Maybe, end with a Maybe\n  * `fmap even (Left 2) = Left 2`: Start with an Either, end with an Either\n  * `fmap even (Right 2) = Right True`: Start with an Either, end with an Either\n  * `fmap even (return 2::IO Int) = True`: The right side is `True::IO Bool`\n* When writing a functor class, you should make sure that the identity function `id` does nothing when fmapped: `fmap id = id`.\n* You should also make sure that your fmap implementation respects function composition:\n  * `fmap (f.g) x = (fmap f) (fmap g x)`\n  * In infix notation: `(f.g) <$> x = f <$> g <$> x`\n\nTo implement a functor on your own data type `X`, use\n```haskell\ninstance Functor X where\n    fmap :: (a -> b) -> X a -> X b\n    ....\n```\n\nAs a concrete example, here is the functor implementation on a `Node` datatype for a binary tree\n\n```haskell\ndata Node a = Node a (Node a) (Node a) | Leaf a | Empty deriving (Eq, Show)\n\ninstance Functor Node where\n    fmap :: (a -> b) -> Node a -> Node b\n    fmap _ (Empty) = Empty\n    fmap f (Leaf a) = Leaf (f a)\n    fmap f (Node a b c) = Node (f a) (fmap f b) (fmap f c)\n```","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"010_functors.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":"cosmo","title-block-banner":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}