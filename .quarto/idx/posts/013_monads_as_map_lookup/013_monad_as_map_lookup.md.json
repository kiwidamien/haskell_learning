{"title":"Monads as Map Lookups","markdown":{"headingText":"Monads as Map Lookups","containsRefs":false,"markdown":"\nThe next two chapters -- Monads and Map Lookups, and Monads as IO -- are going to serve as motivating examples for what additional tools we need. This chapter looks at Maybe as a Monad, with containers (Maps) in the background. Then we look at IO as a Monad that explicitly encodes effects. After giving these examples as motivations, the next chapter will define a Monad in terms of the operations it supports, and without having to mention _effects_ or _Maybe_, as these are not essential elements of a Monad.\n\nThe nice thing about starting with `Maybe` as a Monad is that we can still deal with pure code, and not tie the idea that Monads are necessarily tied to effects. The downside is that it is possible, using pattern matching or case statements, to get around the need for Monads in this case: while the code is uglier, you can always \"extract\" the `a` out of `Just a`, and then deal with `Nothing` separately.\n\nThe `IO` Monad forces us to have to operate within the `IO` context, as we don't have a way of extracting the `String` out of an `IO String`. I put this as a separate motivating example, because `IO` requires introducing a new set of functions that we haven't used yet, and I wanted to reduce confusion by first giving an example of a Monad using only familiar functions.\n\n## Example: Chaining two maps\n\nSuppose we had two maps:\n\n* `zipToCity :: M.Map Int String`. Given a zip code `Int`, return the city name `String`.\n* `cityToState :: M.Map String String`. Given a city name, return the state.\n\nThis is not a great representation for this problem (in particular, the same city name can appear in many states, such as Springfield which exists in 34 states). We are going to assume that all our city names are unique, so this problem does not occur, so that we can make an example with minimal explaination.\n\nHow would we write a function that, given a zip code, would tell you the State?\n\nHere is one work working example of the code:\n```haskell\n{{< include monad_map01.hs >}}\n```\n\nThis works, but we can generalize this a little bit:\n* A Map lookup is `lookup :: a -> M.Map a b -> Maybe b`, that is we are taking ordinary values outside of a `Maybe` context, and getting a result in a `Maybe` context.\n* When chaining lookups, it is difficult because we need the original value (_not_ in a `Maybe`). We can do the deconstruction above, but it is a lot of noise\n* When we get a `Nothing`, we usually want to pass that through to the end. It doesn't add a lot of value for us to pass the `Nothing` explicitly at each chained lookup.\n\nAnother way of phrasing this problem is\n```haskell\nlookupCityFromZip :: Int -> Maybe String\nlookupCityFromZip zipCode = M.lookup zipCode zipToCity\n\nlookupStateFromCity :: String -> Maybe String\nlookupStateFromCity cityName = M.lookup cityName cityToState\n\n-- What we want\n-- useZipCodeFindState :: Int -> Maybe String\n```\n\n## Attempts to build from `fmap` or `<*>`\n\nWe have\n```haskell\n-- From applicative:\npure ::        a       -> Maybe a\n<$>  ::       (a -> b) -> Maybe a -> Maybe b\n<*>  :: Maybe (a -> b) -> Maybe a -> Maybe b\n\n-- Functions that exist\nlookupCityFromZip :: Int -> Maybe String\nlookupStateFromCity :: String -> Maybe String\n\n-- Want\nuseZipCodeFindState :: Int -> Maybe String\n```\n\nWhat we need is something that can take the result of the first lookup (`Maybe String`), and the lookup function `(String -> Maybe String)`, and give us back the result `Maybe String`.\n\nWe can try `<$>` with `a = String` and `b = Maybe String`. Then we have  `lookupStateFromCity` as a function from `a -> b`. We feed it a type `Maybe a`. Unfortunately, we get back a type `Maybe b = Maybe(Maybe String)`\n\n```haskell\nghci> test zipCode = lookupStateFromCity <$> (lookupCityFromZip zipCode)\nghci> test 95616\nJust (Just \"CA\")\nghci> :t test\ntest :: Int -> Maybe (Maybe String)\n```\nNo combination will actually do it. We need to _either_ \n\n* be able to collapse sequential `Maybe` contexts (i.e. make a `Maybe(Maybe String)` into a `Maybe String`)\n* or have a fucntion with the signature `(a -> Maybe b) -> Maybe a -> Maybe b`\n\nIt turns out that these will be two equivalent ways of solving the problem! The first one is called `join`, and the second is called (reverse) `bind`. You can express `join` in terms of `bind`, or `bind` in terms of `join`, so we will pick one and move forward with it.\n\n\nWe pick `reverse bind`:\n```haskell\n=<<   :: (a -> Maybe b) -> Maybe a -> Maybe b\n```\n\nNow we can contruct our chain of lookups:\n```haskell\nghci> lookupCityFromZip           --  Int -> Maybe String \nghci> lookupCityFromZip 95616     -- Maybe String\n-- Lets take a = String, b = String. Then =<< \n--     a (String -> Maybe String) function, lookupStateFromCity\n--     a Maybe String value, lookupCityFromZip 95616\n--     returns a Maybe String value\nghci> (=<<) (lookupStateFromCity) (lookupCityFromZip 95616) -- Maybe String\n-- equivalent as an infix operator\nghci> (lookupStateFromCity) =<< (lookupCityFromZip 95616) \n-- i.e. useZipCodeFindState zipCode = lookupStateFromCity =<< (lookupCityFromZip zipCode)\n```\n\n## Reverse bind `=<<` and bind `>>=`\n\nExtending beyond `Maybe`, we have a pair of very similar functions:\n```haskell\n=<< :: (a -> Context b) -> Context a -> Context b  -- reverse bind\n>>= :: Context a -> (a -> Context b) -> Context b  -- bind\n```\nThese functions are not meaningfully different, we have `f =<< x` and `x >>= f` as functionally the same thing.\n\nReverse bind makes more sense when comparing to `<*>` and `<$>`, and looks more similar to function application (first give the function, then the value in the context being acted on). Haskell programmers tend to use `bind` or `>>=`, which takes the value in context and then pushes it through the function. \n\nWhen I was looking at bind, it seemed somewhat unnatural to do `>>=`, as you start with the value in the context, and then try to push it through a function. This is the complete opposite of what we do with functors and applicatives! However, often when starting to learn Haskell, we often have a value like an `IO String`, or a `Maybe Bool`, and the temptation is to ask \"how do I get the value out of the context?\". Instead, we should operate on the context. Because this is such a frequent sticking point, most Haskell teaching resources prefer bind `>>=` as you start with the troublesome object and _then_ apply a function to it.\n\nYou could write our function `useZipCodeFindState` in either of the following ways:\n```haskell\n-- Using reverse bind =<<.\n-- Looks like regular function application:\n--      start with (lookupCityFromZip zipCode) and get an output\n--      take what is \"inside the context\" as the argument to lookupStateFromCity\n--      just like g $ f x is g( f(x) )\nuseZipCodeFindState zipCode = lookupStateFromCity =<< (lookupCityFromZip zipCode)\n\n-- Using bind >>= \n-- thought of as a function is weird, but it works well thinking about Unix pipes\n-- 1. Calculate (lookupCityFromZip zipCode)\n-- 2. Take the result from \"inside the context\" as the argument to lookupStateFromCity\n-- 3. Calculate\n-- The arrows are a visual reminder of which way we are pushing the data.\nuseZipCodeFindState zipCode = (lookupCityFromZip zipCode) >>= lookupStateFromCity\n```\n\n## Join and Bind\n\nIn our motivating example, we saw that we could _almost_ get away with `fmap`, except that we accumulated contexts. Specifically, we had\n```haskell\nghci> test zipCode = lookupStateFromCity <$> (lookupCityFromZip zipCode)\ngchi> :t test\ntest :: Int -> Maybe (Maybe String)\n```\nwhere what we really wanted was a function from `Int -> Maybe String`.\n\nLet's generalize this. We have two functions, and they each take values (not in a Context), but outputs that are in a Context, and we want to chain them together:\n```haskell\nf1 :: a -> Context b  -- e.g. lookupCityFromZip :: Int -> Maybe String\nf2 :: b -> Context c  -- e.g. lookupStateFromCity :: String -> Maybe String\n\n-- want\nchained :: a -> Context c\n\n-- can make\ndoubleContext :: a -> Context(Context c)\ndoubleContext aType = f2 <$> f1 aType\n```\nLet's walk through the types:\n\n* `f1 aType`: is of type `Context b`\n* `fmap f2 (f1 aType)` has to take inputs `(X->Y)` and `Context X`, and has an output `Context Y`.\n  * Looking at `f2 :: b -> Context c` this means `X = b` and `Y = Context c`.\n  * So this has an output `Context Y = Context (Context c)`.\n\nIf it were possible to flatten the `Context`, we would have what we want! There is a function that does exactly this, called `join`:\n```haskell\njoin :: Context (Context a) -> Context a\n```\n\nLet's assume that we can write `join` as a function. Then we have two ways of combining `f1` and `f2` to make `chained`:\n```haskell\n-- use fmap and then collapse double context to a single context\nchained1 :: a -> Context c\nchained1 aType = join $ doubleContext aType = join $ (f2 <$> f1 aType)\n\n-- use >>=\nchained2 :: a -> Context c\nchained2 aType = f2 <<= (f1 aType)\n```\nThese two approaches give the same result!\n\n### Join and Bind: one in terms of the other\n\nNiether `join` nor `bind` are more fundamental. Given one, you can define the other, to guarantee that the `chained1` and `chained2` approaches do the same thing.\n\nRecall that `>>= :: Context a -> (a -> Context b) -> Context b`. We want a function `join :: Context (Context c) -> Context c`. This suggests:\n\n* `a = Context c` and `b=c` in `>>=`, so we start with `Context (Context c)` and end with `Context c`\n* We need a function `(a -> Context b) = (Context c -> Context c)`. The simplest such function is the identity.\n\nAnd this turns out to be the definition of `join`:\n```haskell\njoin :: Context (Context C) -> Context C\njoin cca = cca >>= id\n```\n\nLet's say that we had a `join` function. Can we make `bind`? Yes we can! From our example above\n```haskell\nchained1 :: a -> Context c\nchained1 aType = join $ (f2 <$> f1 aType)\n\nchained2 :: a -> Context c\nchained2 aType = (>>=) (f1 aType) f2\n```\nBecause these are the same, we have\n```haskell\n(>>=) (f1 aType) f2 = join $ (f2 <$> f1 aType)\n\n-- as a definition\n(>>=) :: Context a -> (a -> Context b) -> Context b\n(>>=) ca fa_to_cb = join $ (fa_to_cb <$> ca)\n```\n\n## Maybe implementation of join and bind\n\nMonad implementation needs us to implement `(>>=)`. The compiler could have made `join` more fundamental, but didn't.\n```haskell\ninstance Monad MyMonad where\n  (>>=) = ...\n```\nLet's do this for `Maybe`\n```haskell\n-- Note this won't run, as it conflicts with the existing declaration in the compiler\ninstance Monad Maybe where\n    -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\n    (>>=) Nothing _ = Nothing\n    (>>=) (Just a) f = f a\n```\nWhat would join be? Let's write it manually, and then also in terms of `bind`\n```haskell\n-- these will run!\njoin :: Monad m => m (m a) -> m a\njoin mma = mma >>= id\n\njoin' :: Maybe (Maybe a) -> Maybe a\njoin' mma = case mma of \n    Nothing -> Nothing\n    Just ma -> ma\n```\n\n## References\n\nThe approach of introducing Monads via sequential map lookups was inspired by _Get Programming With Haskell_ by William Kurt.\n\nThe safediv was inspired by Graham Hutton's introduction to Monads.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"013_monad_as_map_lookup.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":"cosmo","title-block-banner":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}